{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"/**\n * State-based routing for AngularJS\n * @version v0.2.11\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports) {\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n  /*jshint globalstrict:true*/\n  /*global angular:false*/\n  'use strict';\n\n  var isDefined = angular.isDefined,\n      isFunction = angular.isFunction,\n      isString = angular.isString,\n      isObject = angular.isObject,\n      isArray = angular.isArray,\n      forEach = angular.forEach,\n      extend = angular.extend,\n      copy = angular.copy;\n\n  function inherit(parent, extra) {\n    return extend(new (extend(function () {}, { prototype: parent }))(), extra);\n  }\n\n  function merge(dst) {\n    forEach(arguments, function (obj) {\n      if (obj !== dst) {\n        forEach(obj, function (value, key) {\n          if (!dst.hasOwnProperty(key)) dst[key] = value;\n        });\n      }\n    });\n    return dst;\n  }\n\n  /**\n   * Finds the common ancestor path between two states.\n   *\n   * @param {Object} first The first state.\n   * @param {Object} second The second state.\n   * @return {Array} Returns an array of state names in descending order, not including the root.\n   */\n  function ancestors(first, second) {\n    var path = [];\n\n    for (var n in babelHelpers.sanitizeForInObject(first.path)) {\n      if (first.path[n] !== second.path[n]) break;\n      path.push(first.path[n]);\n    }\n    return path;\n  }\n\n  /**\n   * IE8-safe wrapper for `Object.keys()`.\n   *\n   * @param {Object} object A JavaScript object.\n   * @return {Array} Returns the keys of the object as an array.\n   */\n  function objectKeys(object) {\n    if (Object.keys) {\n      return Object.keys(object);\n    }\n    var result = [];\n\n    angular.forEach(object, function (val, key) {\n      result.push(key);\n    });\n    return result;\n  }\n\n  /**\n   * IE8-safe wrapper for `Array.prototype.indexOf()`.\n   *\n   * @param {Array} array A JavaScript array.\n   * @param {*} value A value to search the array for.\n   * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n   */\n  function arraySearch(array, value) {\n    if (Array.prototype.indexOf) {\n      return array.indexOf(value, Number(arguments[2]) || 0);\n    }\n    var len = array.length >>> 0,\n        from = Number(arguments[2]) || 0;\n    from = from < 0 ? Math.ceil(from) : Math.floor(from);\n\n    if (from < 0) from += len;\n\n    for (; from < len; from++) {\n      if (from in array && array[from] === value) return from;\n    }\n    return -1;\n  }\n\n  /**\n   * Merges a set of parameters with all parameters inherited between the common parents of the\n   * current state and a given destination state.\n   *\n   * @param {Object} currentParams The value of the current state parameters ($stateParams).\n   * @param {Object} newParams The set of parameters which will be composited with inherited params.\n   * @param {Object} $current Internal definition of object representing the current state.\n   * @param {Object} $to Internal definition of object representing state to transition to.\n   */\n  function inheritParams(currentParams, newParams, $current, $to) {\n    var parents = ancestors($current, $to),\n        parentParams,\n        inherited = {},\n        inheritList = [];\n\n    for (var i in babelHelpers.sanitizeForInObject(parents)) {\n      if (!parents[i].params) continue;\n      parentParams = objectKeys(parents[i].params);\n      if (!parentParams.length) continue;\n\n      for (var j in babelHelpers.sanitizeForInObject(parentParams)) {\n        if (arraySearch(inheritList, parentParams[j]) >= 0) continue;\n        inheritList.push(parentParams[j]);\n        inherited[parentParams[j]] = currentParams[parentParams[j]];\n      }\n    }\n    return extend({}, inherited, newParams);\n  }\n\n  /**\n   * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n   *\n   * @param {Object} a The first object.\n   * @param {Object} b The second object.\n   * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n   *                     it defaults to the list of keys in `a`.\n   * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n   */\n  function equalForKeys(a, b, keys) {\n    if (!keys) {\n      keys = [];\n      for (var n in babelHelpers.sanitizeForInObject(a)) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i];\n      if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n    }\n    return true;\n  }\n\n  /**\n   * Returns the subset of an object, based on a list of keys.\n   *\n   * @param {Array} keys\n   * @param {Object} values\n   * @return {Boolean} Returns a subset of `values`.\n   */\n  function filterByKeys(keys, values) {\n    var filtered = {};\n\n    forEach(keys, function (name) {\n      filtered[name] = values[name];\n    });\n    return filtered;\n  }\n  /**\n   * @ngdoc overview\n   * @name ui.router.util\n   *\n   * @description\n   * # ui.router.util sub-module\n   *\n   * This module is a dependency of other sub-modules. Do not include this module as a dependency\n   * in your angular app (use {@link ui.router} module instead).\n   *\n   */\n  angular.module('ui.router.util', ['ng']);\n\n  /**\n   * @ngdoc overview\n   * @name ui.router.router\n   * \n   * @requires ui.router.util\n   *\n   * @description\n   * # ui.router.router sub-module\n   *\n   * This module is a dependency of other sub-modules. Do not include this module as a dependency\n   * in your angular app (use {@link ui.router} module instead).\n   */\n  angular.module('ui.router.router', ['ui.router.util']);\n\n  /**\n   * @ngdoc overview\n   * @name ui.router.state\n   * \n   * @requires ui.router.router\n   * @requires ui.router.util\n   *\n   * @description\n   * # ui.router.state sub-module\n   *\n   * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n   * in your angular app (use {@link ui.router} module instead).\n   * \n   */\n  angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n  /**\n   * @ngdoc overview\n   * @name ui.router\n   *\n   * @requires ui.router.state\n   *\n   * @description\n   * # ui.router\n   * \n   * ## The main module for ui.router \n   * There are several sub-modules included with the ui.router module, however only this module is needed\n   * as a dependency within your angular app. The other modules are for organization purposes. \n   *\n   * The modules are:\n   * * ui.router - the main \"umbrella\" module\n   * * ui.router.router - \n   * \n   * *You'll need to include **only** this module as the dependency within your angular app.*\n   * \n   * <pre>\n   * <!doctype html>\n   * <html ng-app=\"myApp\">\n   * <head>\n   *   <script src=\"js/angular.js\"></script>\n   *   <!-- Include the ui-router script -->\n   *   <script src=\"js/angular-ui-router.min.js\"></script>\n   *   <script>\n   *     // ...and add 'ui.router' as a dependency\n   *     var myApp = angular.module('myApp', ['ui.router']);\n   *   </script>\n   * </head>\n   * <body>\n   * </body>\n   * </html>\n   * </pre>\n   */\n  angular.module('ui.router', ['ui.router.state']);\n\n  angular.module('ui.router.compat', ['ui.router']);\n\n  /**\n   * @ngdoc object\n   * @name ui.router.util.$resolve\n   *\n   * @requires $q\n   * @requires $injector\n   *\n   * @description\n   * Manages resolution of (acyclic) graphs of promises.\n   */\n  $Resolve.$inject = ['$q', '$injector'];\n  function $Resolve($q, $injector) {\n\n    var VISIT_IN_PROGRESS = 1,\n        VISIT_DONE = 2,\n        NOTHING = {},\n        NO_DEPENDENCIES = [],\n        NO_LOCALS = NOTHING,\n        NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$resolve#study\n     * @methodOf ui.router.util.$resolve\n     *\n     * @description\n     * Studies a set of invocables that are likely to be used multiple times.\n     * <pre>\n     * $resolve.study(invocables)(locals, parent, self)\n     * </pre>\n     * is equivalent to\n     * <pre>\n     * $resolve.resolve(invocables, locals, parent, self)\n     * </pre>\n     * but the former is more efficient (in fact `resolve` just calls `study` \n     * internally).\n     *\n     * @param {object} invocables Invocable objects\n     * @return {function} a function to pass in locals, parent and self\n     */\n    this.study = function (invocables) {\n      if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\n      // Perform a topological sort of invocables to build an ordered plan\n      var plan = [],\n          cycle = [],\n          visited = {};\n      function visit(value, key) {\n        if (visited[key] === VISIT_DONE) return;\n\n        cycle.push(key);\n        if (visited[key] === VISIT_IN_PROGRESS) {\n          cycle.splice(0, cycle.indexOf(key));\n          throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n        }\n        visited[key] = VISIT_IN_PROGRESS;\n\n        if (isString(value)) {\n          plan.push(key, [function () {\n            return $injector.get(value);\n          }], NO_DEPENDENCIES);\n        } else {\n          var params = $injector.annotate(value);\n          forEach(params, function (param) {\n            if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n          });\n          plan.push(key, value, params);\n        }\n\n        cycle.pop();\n        visited[key] = VISIT_DONE;\n      }\n      forEach(invocables, visit);\n      invocables = cycle = visited = null; // plan is all that's required\n\n      function isResolve(value) {\n        return isObject(value) && value.then && value.$$promises;\n      }\n\n      return function (locals, parent, self) {\n        if (isResolve(locals) && self === undefined) {\n          self = parent;parent = locals;locals = null;\n        }\n        if (!locals) locals = NO_LOCALS;else if (!isObject(locals)) {\n          throw new Error(\"'locals' must be an object\");\n        }\n        if (!parent) parent = NO_PARENT;else if (!isResolve(parent)) {\n          throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n        }\n\n        // To complete the overall resolution, we have to wait for the parent\n        // promise and for the promise for each invokable in our plan.\n        var resolution = $q.defer(),\n            result = resolution.promise,\n            promises = result.$$promises = {},\n            values = extend({}, locals),\n            wait = 1 + plan.length / 3,\n            merged = false;\n\n        function done() {\n          // Merge parent values we haven't got yet and publish our own $$values\n          if (! --wait) {\n            if (!merged) merge(values, parent.$$values);\n            result.$$values = values;\n            result.$$promises = true; // keep for isResolve()\n            delete result.$$inheritedValues;\n            resolution.resolve(values);\n          }\n        }\n\n        function fail(reason) {\n          result.$$failure = reason;\n          resolution.reject(reason);\n        }\n\n        // Short-circuit if parent has already failed\n        if (isDefined(parent.$$failure)) {\n          fail(parent.$$failure);\n          return result;\n        }\n\n        if (parent.$$inheritedValues) {\n          merge(values, parent.$$inheritedValues);\n        }\n\n        // Merge parent values if the parent has already resolved, or merge\n        // parent promises and wait if the parent resolve is still in progress.\n        if (parent.$$values) {\n          merged = merge(values, parent.$$values);\n          result.$$inheritedValues = parent.$$values;\n          done();\n        } else {\n          if (parent.$$inheritedValues) {\n            result.$$inheritedValues = parent.$$inheritedValues;\n          }\n          extend(promises, parent.$$promises);\n          parent.then(done, fail);\n        }\n\n        // Process each invocable in the plan, but ignore any where a local of the same name exists.\n        for (var i = 0, ii = plan.length; i < ii; i += 3) {\n          if (locals.hasOwnProperty(plan[i])) done();else invoke(plan[i], plan[i + 1], plan[i + 2]);\n        }\n\n        function invoke(key, invocable, params) {\n          // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n          var invocation = $q.defer(),\n              waitParams = 0;\n          function onfailure(reason) {\n            invocation.reject(reason);\n            fail(reason);\n          }\n          // Wait for any parameter that we have a promise for (either from parent or from this\n          // resolve; in that case study() will have made sure it's ordered before us in the plan).\n          forEach(params, function (dep) {\n            if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n              waitParams++;\n              promises[dep].then(function (result) {\n                values[dep] = result;\n                if (! --waitParams) proceed();\n              }, onfailure);\n            }\n          });\n          if (!waitParams) proceed();\n          function proceed() {\n            if (isDefined(result.$$failure)) return;\n            try {\n              invocation.resolve($injector.invoke(invocable, self, values));\n              invocation.promise.then(function (result) {\n                values[key] = result;\n                done();\n              }, onfailure);\n            } catch (e) {\n              onfailure(e);\n            }\n          }\n          // Publish promise synchronously; invocations further down in the plan may depend on it.\n          promises[key] = invocation.promise;\n        }\n\n        return result;\n      };\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$resolve#resolve\n     * @methodOf ui.router.util.$resolve\n     *\n     * @description\n     * Resolves a set of invocables. An invocable is a function to be invoked via \n     * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n     * An invocable can either return a value directly,\n     * or a `$q` promise. If a promise is returned it will be resolved and the \n     * resulting value will be used instead. Dependencies of invocables are resolved \n     * (in this order of precedence)\n     *\n     * - from the specified `locals`\n     * - from another invocable that is part of this `$resolve` call\n     * - from an invocable that is inherited from a `parent` call to `$resolve` \n     *   (or recursively\n     * - from any ancestor `$resolve` of that parent).\n     *\n     * The return value of `$resolve` is a promise for an object that contains \n     * (in this order of precedence)\n     *\n     * - any `locals` (if specified)\n     * - the resolved return values of all injectables\n     * - any values inherited from a `parent` call to `$resolve` (if specified)\n     *\n     * The promise will resolve after the `parent` promise (if any) and all promises \n     * returned by injectables have been resolved. If any invocable \n     * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n     * invocable is rejected, the `$resolve` promise is immediately rejected with the \n     * same error. A rejection of a `parent` promise (if specified) will likewise be \n     * propagated immediately. Once the `$resolve` promise has been rejected, no \n     * further invocables will be called.\n     * \n     * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n     * to throw an error. As a special case, an injectable can depend on a parameter \n     * with the same name as the injectable, which will be fulfilled from the `parent` \n     * injectable of the same name. This allows inherited values to be decorated. \n     * Note that in this case any other injectable in the same `$resolve` with the same\n     * dependency would see the decorated value, not the inherited value.\n     *\n     * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n     * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n     * exception.\n     *\n     * Invocables are invoked eagerly as soon as all dependencies are available. \n     * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n     *\n     * As a special case, an invocable can be a string, in which case it is taken to \n     * be a service name to be passed to `$injector.get()`. This is supported primarily \n     * for backwards-compatibility with the `resolve` property of `$routeProvider` \n     * routes.\n     *\n     * @param {object} invocables functions to invoke or \n     * `$injector` services to fetch.\n     * @param {object} locals  values to make available to the injectables\n     * @param {object} parent  a promise returned by another call to `$resolve`.\n     * @param {object} self  the `this` for the invoked methods\n     * @return {object} Promise for an object that contains the resolved return value\n     * of all invocables, as well as any inherited and local values.\n     */\n    this.resolve = function (invocables, locals, parent, self) {\n      return this.study(invocables)(locals, parent, self);\n    };\n  }\n\n  angular.module('ui.router.util').service('$resolve', $Resolve);\n\n  /**\n   * @ngdoc object\n   * @name ui.router.util.$templateFactory\n   *\n   * @requires $http\n   * @requires $templateCache\n   * @requires $injector\n   *\n   * @description\n   * Service. Manages loading of templates.\n   */\n  $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n  function $TemplateFactory($http, $templateCache, $injector) {\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$templateFactory#fromConfig\n     * @methodOf ui.router.util.$templateFactory\n     *\n     * @description\n     * Creates a template from a configuration object. \n     *\n     * @param {object} config Configuration object for which to load a template. \n     * The following properties are search in the specified order, and the first one \n     * that is defined is used to create the template:\n     *\n     * @param {string|object} config.template html string template or function to \n     * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n     * @param {string|object} config.templateUrl url to load or a function returning \n     * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n     * @param {Function} config.templateProvider function to invoke via \n     * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n     * @param {object} params  Parameters to pass to the template function.\n     * @param {object} locals Locals to pass to `invoke` if the template is loaded \n     * via a `templateProvider`. Defaults to `{ params: params }`.\n     *\n     * @return {string|object}  The template html as a string, or a promise for \n     * that string,or `null` if no template is configured.\n     */\n    this.fromConfig = function (config, params, locals) {\n      return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$templateFactory#fromString\n     * @methodOf ui.router.util.$templateFactory\n     *\n     * @description\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param {string|object} template html template as a string or function that \n     * returns an html template as a string.\n     * @param {object} params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that \n     * string.\n     */\n    this.fromString = function (template, params) {\n      return isFunction(template) ? template(params) : template;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$templateFactory#fromUrl\n     * @methodOf ui.router.util.$templateFactory\n     * \n     * @description\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function \n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise \n     * for that string.\n     */\n    this.fromUrl = function (url, params) {\n      if (isFunction(url)) url = url(params);\n      if (url == null) return null;else return $http.get(url, { cache: $templateCache }).then(function (response) {\n        return response.data;\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$templateFactory#fromProvider\n     * @methodOf ui.router.util.$templateFactory\n     *\n     * @description\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param {Function} provider Function to invoke via `$injector.invoke`\n     * @param {Object} params Parameters for the template.\n     * @param {Object} locals Locals to pass to `invoke`. Defaults to \n     * `{ params: params }`.\n     * @return {string|Promise.<string>} The template html as a string, or a promise \n     * for that string.\n     */\n    this.fromProvider = function (provider, params, locals) {\n      return $injector.invoke(provider, null, locals || { params: params });\n    };\n  }\n\n  angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\n  /**\n   * @ngdoc object\n   * @name ui.router.util.type:UrlMatcher\n   *\n   * @description\n   * Matches URLs against patterns and extracts named parameters from the path or the search\n   * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n   * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n   * do not influence whether or not a URL is matched, but their values are passed through into\n   * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n   * \n   * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n   * syntax, which optionally allows a regular expression for the parameter to be specified:\n   *\n   * * `':'` name - colon placeholder\n   * * `'*'` name - catch-all placeholder\n   * * `'{' name '}'` - curly placeholder\n   * * `'{' name ':' regexp '}'` - curly placeholder with regexp. Should the regexp itself contain\n   *   curly braces, they must be in matched pairs or escaped with a backslash.\n   *\n   * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n   * must be unique within the pattern (across both path and search parameters). For colon \n   * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n   * number of characters other than '/'. For catch-all placeholders the path parameter matches\n   * any number of characters.\n   * \n   * Examples:\n   * \n   * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n   *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n   * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n   *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n   * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n   * * `'/user/{id:[^/]*}'` - Same as the previous example.\n   * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n   *   parameter consists of 1 to 8 hex digits.\n   * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n   *   path into the parameter 'path'.\n   * * `'/files/*path'` - ditto.\n   *\n   * @param {string} pattern  The pattern to compile into a matcher.\n   * @param {Object} config  A configuration object hash:\n   *\n   * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n   * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n   *\n   * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n   *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n   *   non-null) will start with this prefix.\n   *\n   * @property {string} source  The pattern that was passed into the constructor\n   *\n   * @property {string} sourcePath  The path portion of the source property\n   *\n   * @property {string} sourceSearch  The search portion of the source property\n   *\n   * @property {string} regex  The constructed regex that will be used to match against the url when \n   *   it is time to determine which url will match.\n   *\n   * @returns {Object}  New `UrlMatcher` object\n   */\n  function UrlMatcher(pattern, config) {\n    config = angular.isObject(config) ? config : {};\n\n    // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n    //   '*' name\n    //   ':' name\n    //   '{' name '}'\n    //   '{' name ':' regexp '}'\n    // The regular expression is somewhat complicated due to the need to allow curly braces\n    // inside the regular expression. The placeholder regexp breaks down as follows:\n    //    ([:*])(\\w+)               classic placeholder ($1 / $2)\n    //    \\{(\\w+)(?:\\:( ... ))?\\}   curly brace placeholder ($3) with optional regexp ... ($4)\n    //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either\n    //    [^{}\\\\]+                  - anything other than curly braces or backslash\n    //    \\\\.                       - a backslash escape\n    //    \\{(?:[^{}\\\\]+|\\\\.)*\\}     - a matched set of curly braces containing other atoms\n    var placeholder = /([:*])(\\w+)|\\{(\\w+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n        compiled = '^',\n        last = 0,\n        m,\n        segments = this.segments = [],\n        params = this.params = {};\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      /*jshint validthis: true */\n      return isDefined(value) ? this.type.decode(value) : $UrlMatcherFactory.$$getDefaultValue(this);\n    }\n\n    function addParameter(id, type, config) {\n      if (!/^\\w+(-+\\w+)*$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n      if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n      params[id] = extend({ type: type || new Type(), $value: $value }, config);\n    }\n\n    function quoteRegExp(string, pattern, isOptional) {\n      var result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n      if (!pattern) return result;\n      var flag = isOptional ? '?' : '';\n      return result + flag + '(' + pattern + ')' + flag;\n    }\n\n    function paramConfig(param) {\n      if (!config.params || !config.params[param]) return {};\n      var cfg = config.params[param];\n      return isObject(cfg) ? cfg : { value: cfg };\n    }\n\n    this.source = pattern;\n\n    // Split into static segments separated by path parameter placeholders.\n    // The number of segments is always 1 more than the number of parameters.\n    var id, regexp, segment, type, cfg;\n\n    while (m = placeholder.exec(pattern)) {\n      id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n      regexp = m[4] || (m[1] == '*' ? '.*' : '[^/]*');\n      segment = pattern.substring(last, m.index);\n      type = this.$types[regexp] || new Type({ pattern: new RegExp(regexp) });\n      cfg = paramConfig(id);\n\n      if (segment.indexOf('?') >= 0) break; // we're into the search part\n\n      compiled += quoteRegExp(segment, type.$subPattern(), isDefined(cfg.value));\n      addParameter(id, type, cfg);\n      segments.push(segment);\n      last = placeholder.lastIndex;\n    }\n    segment = pattern.substring(last);\n\n    // Find any search parameter names and remove them from the last segment\n    var i = segment.indexOf('?');\n\n    if (i >= 0) {\n      var search = this.sourceSearch = segment.substring(i);\n      segment = segment.substring(0, i);\n      this.sourcePath = pattern.substring(0, last + i);\n\n      // Allow parameters to be separated by '?' as well as '&' to make concat() easier\n      forEach(search.substring(1).split(/[&?]/), function (key) {\n        addParameter(key, null, paramConfig(key));\n      });\n    } else {\n      this.sourcePath = pattern;\n      this.sourceSearch = '';\n    }\n\n    compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n    segments.push(segment);\n\n    this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n    this.prefix = segments[0];\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:UrlMatcher#concat\n   * @methodOf ui.router.util.type:UrlMatcher\n   *\n   * @description\n   * Returns a new matcher for a pattern constructed by appending the path part and adding the\n   * search parameters of the specified pattern to this pattern. The current pattern is not\n   * modified. This can be understood as creating a pattern for URLs that are relative to (or\n   * suffixes of) the current pattern.\n   *\n   * @example\n   * The following two matchers are equivalent:\n   * <pre>\n   * new UrlMatcher('/user/{id}?q').concat('/details?date');\n   * new UrlMatcher('/user/{id}/details?q&date');\n   * </pre>\n   *\n   * @param {string} pattern  The pattern to append.\n   * @param {Object} config  An object hash of the configuration for the matcher.\n   * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n   */\n  UrlMatcher.prototype.concat = function (pattern, config) {\n    // Because order of search parameters is irrelevant, we can add our own search\n    // parameters to the end of the new pattern. Parse the new pattern by itself\n    // and then join the bits together, but it's much easier to do this on a string level.\n    return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, config);\n  };\n\n  UrlMatcher.prototype.toString = function () {\n    return this.source;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:UrlMatcher#exec\n   * @methodOf ui.router.util.type:UrlMatcher\n   *\n   * @description\n   * Tests the specified path against this matcher, and returns an object containing the captured\n   * parameter values, or null if the path does not match. The returned object contains the values\n   * of any search parameters that are mentioned in the pattern, but their value may be null if\n   * they are not present in `searchParams`. This means that search parameters are always treated\n   * as optional.\n   *\n   * @example\n   * <pre>\n   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n   *   x: '1', q: 'hello'\n   * });\n   * // returns { id: 'bob', q: 'hello', r: null }\n   * </pre>\n   *\n   * @param {string} path  The URL path to match, e.g. `$location.path()`.\n   * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n   * @returns {Object}  The captured parameter values.\n   */\n  UrlMatcher.prototype.exec = function (path, searchParams) {\n    var m = this.regexp.exec(path);\n    if (!m) return null;\n    searchParams = searchParams || {};\n\n    var params = this.parameters(),\n        nTotal = params.length,\n        nPath = this.segments.length - 1,\n        values = {},\n        i,\n        cfg,\n        param;\n\n    if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n    for (i = 0; i < nPath; i++) {\n      param = params[i];\n      cfg = this.params[param];\n      values[param] = cfg.$value(m[i + 1]);\n    }\n    for (; /**/i < nTotal; i++) {\n      param = params[i];\n      cfg = this.params[param];\n      values[param] = cfg.$value(searchParams[param]);\n    }\n\n    return values;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:UrlMatcher#parameters\n   * @methodOf ui.router.util.type:UrlMatcher\n   *\n   * @description\n   * Returns the names of all path and search parameters of this pattern in an unspecified order.\n   * \n   * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n   *    pattern has no parameters, an empty array is returned.\n   */\n  UrlMatcher.prototype.parameters = function (param) {\n    if (!isDefined(param)) return objectKeys(this.params);\n    return this.params[param] || null;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:UrlMatcher#validate\n   * @methodOf ui.router.util.type:UrlMatcher\n   *\n   * @description\n   * Checks an object hash of parameters to validate their correctness according to the parameter\n   * types of this `UrlMatcher`.\n   *\n   * @param {Object} params The object hash of parameters to validate.\n   * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n   */\n  UrlMatcher.prototype.validates = function (params) {\n    var result = true,\n        isOptional,\n        cfg,\n        self = this;\n\n    forEach(params, function (val, key) {\n      if (!self.params[key]) return;\n      cfg = self.params[key];\n      isOptional = !val && isDefined(cfg.value);\n      result = result && (isOptional || cfg.type.is(val));\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:UrlMatcher#format\n   * @methodOf ui.router.util.type:UrlMatcher\n   *\n   * @description\n   * Creates a URL that matches this pattern by substituting the specified values\n   * for the path and search parameters. Null values for path parameters are\n   * treated as empty strings.\n   *\n   * @example\n   * <pre>\n   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n   * // returns '/user/bob?q=yes'\n   * </pre>\n   *\n   * @param {Object} values  the values to substitute for the parameters in this pattern.\n   * @returns {string}  the formatted URL (path and optionally search part).\n   */\n  UrlMatcher.prototype.format = function (values) {\n    var segments = this.segments,\n        params = this.parameters();\n\n    if (!values) return segments.join('').replace('//', '/');\n\n    var nPath = segments.length - 1,\n        nTotal = params.length,\n        result = segments[0],\n        i,\n        search,\n        value,\n        param,\n        cfg,\n        array;\n\n    if (!this.validates(values)) return null;\n\n    for (i = 0; i < nPath; i++) {\n      param = params[i];\n      value = values[param];\n      cfg = this.params[param];\n\n      if (!isDefined(value) && (segments[i] === '/' || segments[i + 1] === '/')) continue;\n      if (value != null) result += encodeURIComponent(cfg.type.encode(value));\n      result += segments[i + 1];\n    }\n\n    for (; /**/i < nTotal; i++) {\n      param = params[i];\n      value = values[param];\n      if (value == null) continue;\n      array = isArray(value);\n\n      if (array) {\n        value = value.map(encodeURIComponent).join('&' + param + '=');\n      }\n      result += (search ? '&' : '?') + param + '=' + (array ? value : encodeURIComponent(value));\n      search = true;\n    }\n    return result;\n  };\n\n  UrlMatcher.prototype.$types = {};\n\n  /**\n   * @ngdoc object\n   * @name ui.router.util.type:Type\n   *\n   * @description\n   * Implements an interface to define custom parameter types that can be decoded from and encoded to\n   * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n   * objects when matching or formatting URLs, or comparing or validating parameter values.\n   *\n   * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n   * information on registering custom types.\n   *\n   * @param {Object} config  A configuration object hash that includes any method in `Type`'s public\n   *        interface, and/or `pattern`, which should contain a custom regular expression used to match\n   *        string parameters originating from a URL.\n   *\n   * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n   *           coming from a substring of a URL.\n   *\n   * @returns {Object}  Returns a new `Type` object.\n   */\n  function Type(config) {\n    extend(this, config);\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:Type#is\n   * @methodOf ui.router.util.type:Type\n   *\n   * @description\n   * Detects whether a value is of a particular type. Accepts a native (decoded) value\n   * and determines whether it matches the current `Type` object.\n   *\n   * @param {*} val  The value to check.\n   * @param {string} key  Optional. If the type check is happening in the context of a specific\n   *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n   *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n   * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n   */\n  Type.prototype.is = function (val, key) {\n    return true;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:Type#encode\n   * @methodOf ui.router.util.type:Type\n   *\n   * @description\n   * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n   * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n   * only needs to be a representation of `val` that has been coerced to a string.\n   *\n   * @param {*} val  The value to encode.\n   * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n   *        meta-programming of `Type` objects.\n   * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n   */\n  Type.prototype.encode = function (val, key) {\n    return val;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:Type#decode\n   * @methodOf ui.router.util.type:Type\n   *\n   * @description\n   * Converts a string URL parameter value to a custom/native value.\n   *\n   * @param {string} val  The URL parameter value to decode.\n   * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n   *        meta-programming of `Type` objects.\n   * @returns {*}  Returns a custom representation of the URL parameter value.\n   */\n  Type.prototype.decode = function (val, key) {\n    return val;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.type:Type#equals\n   * @methodOf ui.router.util.type:Type\n   *\n   * @description\n   * Determines whether two decoded values are equivalent.\n   *\n   * @param {*} a  A value to compare against.\n   * @param {*} b  A value to compare against.\n   * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n   */\n  Type.prototype.equals = function (a, b) {\n    return a == b;\n  };\n\n  Type.prototype.$subPattern = function () {\n    var sub = this.pattern.toString();\n    return sub.substr(1, sub.length - 2);\n  };\n\n  Type.prototype.pattern = /.*/;\n\n  /**\n   * @ngdoc object\n   * @name ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n   * is also available to providers under the name `$urlMatcherFactoryProvider`.\n   */\n  function $UrlMatcherFactory() {\n\n    var isCaseInsensitive = false,\n        isStrictMode = true;\n\n    var enqueue = true,\n        typeQueue = [],\n        injector,\n        defaultTypes = {\n      int: {\n        decode: function (val) {\n          return parseInt(val, 10);\n        },\n        is: function (val) {\n          if (!isDefined(val)) return false;\n          return this.decode(val.toString()) === val;\n        },\n        pattern: /\\d+/\n      },\n      bool: {\n        encode: function (val) {\n          return val ? 1 : 0;\n        },\n        decode: function (val) {\n          return parseInt(val, 10) === 0 ? false : true;\n        },\n        is: function (val) {\n          return val === true || val === false;\n        },\n        pattern: /0|1/\n      },\n      string: {\n        pattern: /[^\\/]*/\n      },\n      date: {\n        equals: function (a, b) {\n          return a.toISOString() === b.toISOString();\n        },\n        decode: function (val) {\n          return new Date(val);\n        },\n        encode: function (val) {\n          return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join(\"-\");\n        },\n        pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/\n      }\n    };\n\n    function getDefaultConfig() {\n      return {\n        strict: isStrictMode,\n        caseInsensitive: isCaseInsensitive\n      };\n    }\n\n    function isInjectable(value) {\n      return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    $UrlMatcherFactory.$$getDefaultValue = function (config) {\n      if (!isInjectable(config.value)) return config.value;\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      return injector.invoke(config.value);\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n     * @methodOf ui.router.util.$urlMatcherFactory\n     *\n     * @description\n     * Defines whether URL matching should be case sensitive (the default behavior), or not.\n     *\n     * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n     */\n    this.caseInsensitive = function (value) {\n      isCaseInsensitive = value;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$urlMatcherFactory#strictMode\n     * @methodOf ui.router.util.$urlMatcherFactory\n     *\n     * @description\n     * Defines whether URLs should match trailing slashes, or not (the default behavior).\n     *\n     * @param {boolean} value `false` to match trailing slashes in URLs, otherwise `true`.\n     */\n    this.strictMode = function (value) {\n      isStrictMode = value;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$urlMatcherFactory#compile\n     * @methodOf ui.router.util.$urlMatcherFactory\n     *\n     * @description\n     * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n     *   \n     * @param {string} pattern  The URL pattern.\n     * @param {Object} config  The config object hash.\n     * @returns {UrlMatcher}  The UrlMatcher.\n     */\n    this.compile = function (pattern, config) {\n      return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$urlMatcherFactory#isMatcher\n     * @methodOf ui.router.util.$urlMatcherFactory\n     *\n     * @description\n     * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n     *\n     * @param {Object} object  The object to perform the type check against.\n     * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    this.isMatcher = function (o) {\n      if (!isObject(o)) return false;\n      var result = true;\n\n      forEach(UrlMatcher.prototype, function (val, name) {\n        if (isFunction(val)) {\n          result = result && (isDefined(o[name]) && isFunction(o[name]));\n        }\n      });\n      return result;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.util.$urlMatcherFactory#type\n     * @methodOf ui.router.util.$urlMatcherFactory\n     *\n     * @description\n     * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n     * generate URLs with typed parameters.\n     *\n     * @param {string} name  The type name.\n     * @param {Object|Function} def  The type definition. See\n     *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n     *\n     * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n     *\n     * @example\n     * This is a simple example of a custom type that encodes and decodes items from an\n     * array, using the array index as the URL-encoded value:\n     *\n     * <pre>\n     * var list = ['John', 'Paul', 'George', 'Ringo'];\n     *\n     * $urlMatcherFactoryProvider.type('listItem', {\n     *   encode: function(item) {\n     *     // Represent the list item in the URL using its corresponding index\n     *     return list.indexOf(item);\n     *   },\n     *   decode: function(item) {\n     *     // Look up the list item by index\n     *     return list[parseInt(item, 10)];\n     *   },\n     *   is: function(item) {\n     *     // Ensure the item is valid by checking to see that it appears\n     *     // in the list\n     *     return list.indexOf(item) > -1;\n     *   }\n     * });\n     *\n     * $stateProvider.state('list', {\n     *   url: \"/list/{item:listItem}\",\n     *   controller: function($scope, $stateParams) {\n     *     console.log($stateParams.item);\n     *   }\n     * });\n     *\n     * // ...\n     *\n     * // Changes URL to '/list/3', logs \"Ringo\" to the console\n     * $state.go('list', { item: \"Ringo\" });\n     * </pre>\n     *\n     * This is a more complex example of a type that relies on dependency injection to\n     * interact with services, and uses the parameter name from the URL to infer how to\n     * handle encoding and decoding parameter values:\n     *\n     * <pre>\n     * // Defines a custom type that gets a value from a service,\n     * // where each service gets different types of values from\n     * // a backend API:\n     * $urlMatcherFactoryProvider.type('dbObject', function(Users, Posts) {\n     *\n     *   // Matches up services to URL parameter names\n     *   var services = {\n     *     user: Users,\n     *     post: Posts\n     *   };\n     *\n     *   return {\n     *     encode: function(object) {\n     *       // Represent the object in the URL using its unique ID\n     *       return object.id;\n     *     },\n     *     decode: function(value, key) {\n     *       // Look up the object by ID, using the parameter\n     *       // name (key) to call the correct service\n     *       return services[key].findById(value);\n     *     },\n     *     is: function(object, key) {\n     *       // Check that object is a valid dbObject\n     *       return angular.isObject(object) && object.id && services[key];\n     *     }\n     *     equals: function(a, b) {\n     *       // Check the equality of decoded objects by comparing\n     *       // their unique IDs\n     *       return a.id === b.id;\n     *     }\n     *   };\n     * });\n     *\n     * // In a config() block, you can then attach URLs with\n     * // type-annotated parameters:\n     * $stateProvider.state('users', {\n     *   url: \"/users\",\n     *   // ...\n     * }).state('users.item', {\n     *   url: \"/{user:dbObject}\",\n     *   controller: function($scope, $stateParams) {\n     *     // $stateParams.user will now be an object returned from\n     *     // the Users service\n     *   },\n     *   // ...\n     * });\n     * </pre>\n     */\n    this.type = function (name, def) {\n      if (!isDefined(def)) return UrlMatcher.prototype.$types[name];\n      typeQueue.push({ name: name, def: def });\n      if (!enqueue) flushTypeQueue();\n      return this;\n    };\n\n    /* No need to document $get, since it returns this */\n    this.$get = ['$injector', function ($injector) {\n      injector = $injector;\n      enqueue = false;\n      UrlMatcher.prototype.$types = {};\n      flushTypeQueue();\n\n      forEach(defaultTypes, function (type, name) {\n        if (!UrlMatcher.prototype.$types[name]) UrlMatcher.prototype.$types[name] = new Type(type);\n      });\n      return this;\n    }];\n\n    // To ensure proper order of operations in object configuration, and to allow internal\n    // types to be overridden, `flushTypeQueue()` waits until `$urlMatcherFactory` is injected\n    // before actually wiring up and assigning type definitions\n    function flushTypeQueue() {\n      forEach(typeQueue, function (type) {\n        if (UrlMatcher.prototype.$types[type.name]) {\n          throw new Error(\"A type named '\" + type.name + \"' has already been defined.\");\n        }\n        var def = new Type(isInjectable(type.def) ? injector.invoke(type.def) : type.def);\n        UrlMatcher.prototype.$types[type.name] = def;\n      });\n    }\n  }\n\n  // Register as a provider so it's available to other providers\n  angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider\n   *\n   * @requires ui.router.util.$urlMatcherFactoryProvider\n   * @requires $locationProvider\n   *\n   * @description\n   * `$urlRouterProvider` has the responsibility of watching `$location`. \n   * When `$location` changes it runs through a list of rules one by one until a \n   * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n   * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n   *\n   * There are several methods on `$urlRouterProvider` that make it useful to use directly\n   * in your module config.\n   */\n  $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n  function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {\n    var rules = [],\n        otherwise = null,\n        interceptDeferred = false,\n        listener;\n\n    // Returns a string that is a prefix of all strings matching the RegExp\n    function regExpPrefix(re) {\n      var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n      return prefix != null ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n    }\n\n    // Interpolates matched values into a String.replace()-style pattern\n    function interpolate(pattern, match) {\n      return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n        return match[what === '$' ? 0 : Number(what)];\n      });\n    }\n\n    /**\n     * @ngdoc function\n     * @name ui.router.router.$urlRouterProvider#rule\n     * @methodOf ui.router.router.$urlRouterProvider\n     *\n     * @description\n     * Defines rules that are used by `$urlRouterProvider` to find matches for\n     * specific URLs.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * </pre>\n     *\n     * @param {object} rule Handler function that takes `$injector` and `$location`\n     * services as arguments. You can use them to return a valid path as a string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    this.rule = function (rule) {\n      if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n      rules.push(rule);\n      return this;\n    };\n\n    /**\n     * @ngdoc object\n     * @name ui.router.router.$urlRouterProvider#otherwise\n     * @methodOf ui.router.router.$urlRouterProvider\n     *\n     * @description\n     * Defines a path that is used when an invalid route is requested.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * </pre>\n     *\n     * @param {string|object} rule The url path you want to redirect to or a function \n     * rule that returns the url path. The function version is passed two params: \n     * `$injector` and `$location` services, and must return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    this.otherwise = function (rule) {\n      if (isString(rule)) {\n        var redirect = rule;\n        rule = function () {\n          return redirect;\n        };\n      } else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n      otherwise = rule;\n      return this;\n    };\n\n    function handleIfMatch($injector, handler, match) {\n      if (!match) return false;\n      var result = $injector.invoke(handler, handler, { $match: match });\n      return isDefined(result) ? result : true;\n    }\n\n    /**\n     * @ngdoc function\n     * @name ui.router.router.$urlRouterProvider#when\n     * @methodOf ui.router.router.$urlRouterProvider\n     *\n     * @description\n     * Registers a handler for a given url matching. if handle is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable. It gets invoked if `$location`\n     * matches. You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * </pre>\n     *\n     * @param {string|object} what The incoming path that you want to redirect.\n     * @param {string|object} handler The path you want to redirect your user to.\n     */\n    this.when = function (what, handler) {\n      var redirect,\n          handlerIsString = isString(handler);\n      if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n      if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error(\"invalid 'handler' in when()\");\n\n      var strategies = {\n        matcher: function (what, handler) {\n          if (handlerIsString) {\n            redirect = $urlMatcherFactory.compile(handler);\n            handler = ['$match', function ($match) {\n              return redirect.format($match);\n            }];\n          }\n          return extend(function ($injector, $location) {\n            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n          }, {\n            prefix: isString(what.prefix) ? what.prefix : ''\n          });\n        },\n        regex: function (what, handler) {\n          if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n          if (handlerIsString) {\n            redirect = handler;\n            handler = ['$match', function ($match) {\n              return interpolate(redirect, $match);\n            }];\n          }\n          return extend(function ($injector, $location) {\n            return handleIfMatch($injector, handler, what.exec($location.path()));\n          }, {\n            prefix: regExpPrefix(what)\n          });\n        }\n      };\n\n      var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n      for (var n in babelHelpers.sanitizeForInObject(check)) {\n        if (check[n]) return this.rule(strategies[n](what, handler));\n      }\n\n      throw new Error(\"invalid 'what' in when()\");\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.router.$urlRouterProvider#deferIntercept\n     * @methodOf ui.router.router.$urlRouterProvider\n     *\n     * @description\n     * Disables (or enables) deferring location change interception.\n     *\n     * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n     * defer a transition but maintain the current URL), call this method at configuration time.\n     * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n     * `$locationChangeSuccess` event handler.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   // this allows you to configure custom behavior in between\n     *   // location changes and route synchronization:\n     *   $urlRouterProvider.deferIntercept();\n     *\n     * }).run(function ($rootScope, $urlRouter, UserService) {\n     *\n     *   $rootScope.$on('$locationChangeSuccess', function(e) {\n     *     // UserService is an example service for managing user state\n     *     if (UserService.isLoggedIn()) return;\n     *\n     *     // Prevent $urlRouter's default handler from firing\n     *     e.preventDefault();\n     *\n     *     UserService.handleLogin().then(function() {\n     *       // Once the user has logged in, sync the current URL\n     *       // to the router:\n     *       $urlRouter.sync();\n     *     });\n     *   });\n     *\n     *   // Configures $urlRouter's listener *after* your custom listener\n     *   $urlRouter.listen();\n     * });\n     * </pre>\n     *\n     * @param {boolean} defer Indicates whether to defer location change interception. Passing\n              no parameter is equivalent to `true`.\n     */\n    this.deferIntercept = function (defer) {\n      if (defer === undefined) defer = true;\n      interceptDeferred = defer;\n    };\n\n    /**\n     * @ngdoc object\n     * @name ui.router.router.$urlRouter\n     *\n     * @requires $location\n     * @requires $rootScope\n     * @requires $injector\n     * @requires $browser\n     *\n     * @description\n     *\n     */\n    this.$get = $get;\n    $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n    function $get($location, $rootScope, $injector, $browser) {\n\n      var baseHref = $browser.baseHref(),\n          location = $location.url();\n\n      function appendBasePath(url, isHtml5, absolute) {\n        if (baseHref === '/') return url;\n        if (isHtml5) return baseHref.slice(0, -1) + url;\n        if (absolute) return baseHref.slice(1) + url;\n        return url;\n      }\n\n      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n      function update(evt) {\n        if (evt && evt.defaultPrevented) return;\n\n        function check(rule) {\n          var handled = rule($injector, $location);\n\n          if (!handled) return false;\n          if (isString(handled)) $location.replace().url(handled);\n          return true;\n        }\n        var n = rules.length,\n            i;\n\n        for (i = 0; i < n; i++) {\n          if (check(rules[i])) return;\n        }\n        // always check otherwise last to allow dynamic updates to the set of rules\n        if (otherwise) check(otherwise);\n      }\n\n      function listen() {\n        listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n        return listener;\n      }\n\n      if (!interceptDeferred) listen();\n\n      return {\n        /**\n         * @ngdoc function\n         * @name ui.router.router.$urlRouter#sync\n         * @methodOf ui.router.router.$urlRouter\n         *\n         * @description\n         * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n         * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n         * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n         * with the transition by calling `$urlRouter.sync()`.\n         *\n         * @example\n         * <pre>\n         * angular.module('app', ['ui.router'])\n         *   .run(function($rootScope, $urlRouter) {\n         *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n         *       // Halt state change from even starting\n         *       evt.preventDefault();\n         *       // Perform custom logic\n         *       var meetsRequirement = ...\n         *       // Continue with the update and state transition if logic allows\n         *       if (meetsRequirement) $urlRouter.sync();\n         *     });\n         * });\n         * </pre>\n         */\n        sync: function () {\n          update();\n        },\n\n        listen: function () {\n          return listen();\n        },\n\n        update: function (read) {\n          if (read) {\n            location = $location.url();\n            return;\n          }\n          if ($location.url() === location) return;\n\n          $location.url(location);\n          $location.replace();\n        },\n\n        push: function (urlMatcher, params, options) {\n          $location.url(urlMatcher.format(params || {}));\n          if (options && options.replace) $location.replace();\n        },\n\n        /**\n         * @ngdoc function\n         * @name ui.router.router.$urlRouter#href\n         * @methodOf ui.router.router.$urlRouter\n         *\n         * @description\n         * A URL generation method that returns the compiled URL for a given\n         * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n         *\n         * @example\n         * <pre>\n         * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n         *   person: \"bob\"\n         * });\n         * // $bob == \"/about/bob\";\n         * </pre>\n         *\n         * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n         * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n         * @param {object=} options Options object. The options are:\n         *\n         * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n         *\n         * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n         */\n        href: function (urlMatcher, params, options) {\n          if (!urlMatcher.validates(params)) return null;\n\n          var isHtml5 = $locationProvider.html5Mode();\n          var url = urlMatcher.format(params);\n          options = options || {};\n\n          if (!isHtml5 && url !== null) {\n            url = \"#\" + $locationProvider.hashPrefix() + url;\n          }\n          url = appendBasePath(url, isHtml5, options.absolute);\n\n          if (!options.absolute || !url) {\n            return url;\n          }\n\n          var slash = !isHtml5 && url ? '/' : '',\n              port = $location.port();\n          port = port === 80 || port === 443 ? '' : ':' + port;\n\n          return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n        }\n      };\n    }\n  }\n\n  angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$stateProvider\n   *\n   * @requires ui.router.router.$urlRouterProvider\n   * @requires ui.router.util.$urlMatcherFactoryProvider\n   *\n   * @description\n   * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n   * on state.\n   *\n   * A state corresponds to a \"place\" in the application in terms of the overall UI and\n   * navigation. A state describes (via the controller / template / view properties) what\n   * the UI looks like and does at that place.\n   *\n   * States often have things in common, and the primary way of factoring out these\n   * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n   * nested states.\n   *\n   * The `$stateProvider` provides interfaces to declare these states for your app.\n   */\n  $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n  function $StateProvider($urlRouterProvider, $urlMatcherFactory) {\n\n    var root,\n        states = {},\n        $state,\n        queue = {},\n        abstractKey = 'abstract';\n\n    // Builds state properties from definition passed to registerState()\n    var stateBuilder = {\n\n      // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n      // state.children = [];\n      // if (parent) parent.children.push(state);\n      parent: function (state) {\n        if (isDefined(state.parent) && state.parent) return findState(state.parent);\n        // regex matches any valid composite state name\n        // would match \"contact.list\" but not \"contacts\"\n        var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n        return compositeName ? findState(compositeName[1]) : root;\n      },\n\n      // inherit 'data' from parent and override by own values (if any)\n      data: function (state) {\n        if (state.parent && state.parent.data) {\n          state.data = state.self.data = extend({}, state.parent.data, state.data);\n        }\n        return state.data;\n      },\n\n      // Build a URLMatcher if necessary, either via a relative or absolute URL\n      url: function (state) {\n        var url = state.url,\n            config = { params: state.params || {} };\n\n        if (isString(url)) {\n          if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n          return (state.parent.navigable || root).url.concat(url, config);\n        }\n\n        if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n        throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n      },\n\n      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n      navigable: function (state) {\n        return state.url ? state : state.parent ? state.parent.navigable : null;\n      },\n\n      // Derive parameters for this state and ensure they're a super-set of parent's parameters\n      params: function (state) {\n        if (!state.params) {\n          return state.url ? state.url.params : state.parent.params;\n        }\n        return state.params;\n      },\n\n      // If there is no explicit multi-view configuration, make one up so we don't have\n      // to handle both cases in the view directive later. Note that having an explicit\n      // 'views' property will mean the default unnamed view properties are ignored. This\n      // is also a good time to resolve view names to absolute names, so everything is a\n      // straight lookup at link time.\n      views: function (state) {\n        var views = {};\n\n        forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n          if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n          views[name] = view;\n        });\n        return views;\n      },\n\n      ownParams: function (state) {\n        state.params = state.params || {};\n\n        if (!state.parent) {\n          return objectKeys(state.params);\n        }\n        var paramNames = {};forEach(state.params, function (v, k) {\n          paramNames[k] = true;\n        });\n\n        forEach(state.parent.params, function (v, k) {\n          if (!paramNames[k]) {\n            throw new Error(\"Missing required parameter '\" + k + \"' in state '\" + state.name + \"'\");\n          }\n          paramNames[k] = false;\n        });\n        var ownParams = [];\n\n        forEach(paramNames, function (own, p) {\n          if (own) ownParams.push(p);\n        });\n        return ownParams;\n      },\n\n      // Keep a full path from the root down to this state as this is needed for state activation.\n      path: function (state) {\n        return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n      },\n\n      // Speed up $state.contains() as it's used a lot\n      includes: function (state) {\n        var includes = state.parent ? extend({}, state.parent.includes) : {};\n        includes[state.name] = true;\n        return includes;\n      },\n\n      $delegates: {}\n    };\n\n    function isRelative(stateName) {\n      return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    }\n\n    function findState(stateOrName, base) {\n      if (!stateOrName) return undefined;\n\n      var isStr = isString(stateOrName),\n          name = isStr ? stateOrName : stateOrName.name,\n          path = isRelative(name);\n\n      if (path) {\n        if (!base) throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var rel = name.split(\".\"),\n            i = 0,\n            pathLength = rel.length,\n            current = base;\n\n        for (; i < pathLength; i++) {\n          if (rel[i] === \"\" && i === 0) {\n            current = base;\n            continue;\n          }\n          if (rel[i] === \"^\") {\n            if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n            current = current.parent;\n            continue;\n          }\n          break;\n        }\n        rel = rel.slice(i).join(\".\");\n        name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n      }\n      var state = states[name];\n\n      if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {\n        return state;\n      }\n      return undefined;\n    }\n\n    function queueState(parentName, state) {\n      if (!queue[parentName]) {\n        queue[parentName] = [];\n      }\n      queue[parentName].push(state);\n    }\n\n    function registerState(state) {\n      // Wrap a new object around the state so we can store our private details easily.\n      state = inherit(state, {\n        self: state,\n        resolve: state.resolve || {},\n        toString: function () {\n          return this.name;\n        }\n      });\n\n      var name = state.name;\n      if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n      if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n      // Get parent name\n      var parentName = name.indexOf('.') !== -1 ? name.substring(0, name.lastIndexOf('.')) : isString(state.parent) ? state.parent : '';\n\n      // If parent is not registered yet, add state to queue and register later\n      if (parentName && !states[parentName]) {\n        return queueState(parentName, state.self);\n      }\n\n      for (var key in babelHelpers.sanitizeForInObject(stateBuilder)) {\n        if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n      }\n      states[name] = state;\n\n      // Register the state in the global state list and with $urlRouter if necessary.\n      if (!state[abstractKey] && state.url) {\n        $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n          if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n            $state.transitionTo(state, $match, { location: false });\n          }\n        }]);\n      }\n\n      // Register any queued children\n      if (queue[name]) {\n        for (var i = 0; i < queue[name].length; i++) {\n          registerState(queue[name][i]);\n        }\n      }\n\n      return state;\n    }\n\n    // Checks text to see if it looks like a glob.\n    function isGlob(text) {\n      return text.indexOf('*') > -1;\n    }\n\n    // Returns true if glob matches current $state name.\n    function doesStateMatchGlob(glob) {\n      var globSegments = glob.split('.'),\n          segments = $state.$current.name.split('.');\n\n      //match greedy starts\n      if (globSegments[0] === '**') {\n        segments = segments.slice(segments.indexOf(globSegments[1]));\n        segments.unshift('**');\n      }\n      //match greedy ends\n      if (globSegments[globSegments.length - 1] === '**') {\n        segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n        segments.push('**');\n      }\n\n      if (globSegments.length != segments.length) {\n        return false;\n      }\n\n      //match single stars\n      for (var i = 0, l = globSegments.length; i < l; i++) {\n        if (globSegments[i] === '*') {\n          segments[i] = '*';\n        }\n      }\n\n      return segments.join('') === globSegments.join('');\n    }\n\n    // Implicit root state that is always active\n    root = registerState({\n      name: '',\n      url: '^',\n      views: null,\n      'abstract': true\n    });\n    root.navigable = null;\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$stateProvider#decorator\n     * @methodOf ui.router.state.$stateProvider\n     *\n     * @description\n     * Allows you to extend (carefully) or override (at your own peril) the \n     * `stateBuilder` object used internally by `$stateProvider`. This can be used \n     * to add custom functionality to ui-router, for example inferring templateUrl \n     * based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new \n     * properties within the state's internal definition. There is currently no clear \n     * use-case for this beyond accessing internal states (i.e. $state.$current), \n     * however, expect this to become increasingly relevant as we introduce additional \n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of \n     * execution of the builder functions in non-deterministic. Builder functions \n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to \n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view \n     *   name (i.e. \"viewName@stateName\") and each value is the config object \n     *   (template, controller) for the view. Even when you don't use the views object \n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template \n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state, \n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state. \n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that \n     *   would pass a `$state.includes()` test.\n     *\n     * @example\n     * <pre>\n     * // Override the internal 'views' builder with a function that takes the state\n     * // definition, and a reference to the internal function being overridden:\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   var result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     var autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     *\n     * // ...\n     *\n     * $state.go('home');\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * </pre>\n     *\n     * @param {string} name The name of the builder function to decorate. \n     * @param {object} func A function that is responsible for decorating the original \n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    this.decorator = decorator;\n    function decorator(name, func) {\n      /*jshint validthis: true */\n      if (isString(name) && !isDefined(func)) {\n        return stateBuilder[name];\n      }\n      if (!isFunction(func) || !isString(name)) {\n        return this;\n      }\n      if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n        stateBuilder.$delegates[name] = stateBuilder[name];\n      }\n      stateBuilder[name] = func;\n      return this;\n    }\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$stateProvider#state\n     * @methodOf ui.router.state.$stateProvider\n     *\n     * @description\n     * Registers a state configuration under a given state name. The stateConfig object\n     * has the following acceptable properties.\n     *\n     * <a id='template'></a>\n     *\n     * - **`template`** - {string|function=} - html template as a string or a function that returns\n     *   an html template as a string which should be used by the uiView directives. This property \n     *   takes precedence over templateUrl.\n     *   \n     *   If `template` is a function, it will be called with the following parameters:\n     *\n     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n     *     applying the current state\n     *\n     * <a id='templateUrl'></a>\n     *\n     * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html \n     *   template that should be used by uiView.\n     *   \n     *   If `templateUrl` is a function, it will be called with the following parameters:\n     *\n     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n     *     applying the current state\n     *\n     * <a id='templateProvider'></a>\n     *\n     * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n     *   string.\n     *\n     * <a id='controller'></a>\n     *\n     * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly \n     *   related scope or the name of a registered controller if passed as a string.\n     *\n     * <a id='controllerProvider'></a>\n     *\n     * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n     *   the actual controller or string.\n     *\n     * <a id='controllerAs'></a>\n     * \n     * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be \n     *   published to scope under the controllerAs name.\n     *\n     * <a id='resolve'></a>\n     *\n     * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which \n     *   should be injected into the controller. If any of these dependencies are promises, \n     *   the router will wait for them all to be resolved or one to be rejected before the \n     *   controller is instantiated. If all the promises are resolved successfully, the values \n     *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any \n     *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n     *   \n     *   - key - {string}: name of dependency to be injected into controller\n     *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n     *     it is injected and return value it treated as dependency. If result is a promise, it is \n     *     resolved before its value is injected into controller.\n     *\n     * <a id='url'></a>\n     *\n     * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n     *   transitioned to, the `$stateParams` service will be populated with any \n     *   parameters that were passed.\n     *\n     * <a id='params'></a>\n     *\n     * - **`params`** - {object=} - An array of parameter names or regular expressions. Only \n     *   use this within a state if you are not using url. Otherwise you can specify your\n     *   parameters within the url. When a state is navigated or transitioned to, the \n     *   $stateParams service will be populated with any parameters that were passed.\n     *\n     * <a id='views'></a>\n     *\n     * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n     *   manually/explicitly.\n     *\n     * <a id='abstract'></a>\n     *\n     * - **`abstract`** - {boolean=} - An abstract state will never be directly activated, \n     *   but can provide inherited properties to its common children states.\n     *\n     * <a id='onEnter'></a>\n     *\n     * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n     *   to trigger an action or dispatch an event, such as opening a dialog.\n     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n     *\n     * <a id='onExit'></a>\n     *\n     * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n     *   trigger an action or dispatch an event, such as opening a dialog.\n     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n     *\n     * <a id='reloadOnSearch'></a>\n     *\n     * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state \n     *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n     *   Useful for when you'd like to modify $location.search() without triggering a reload.\n     *\n     * <a id='data'></a>\n     *\n     * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n     *\n     * @example\n     * <pre>\n     * // Some state name examples\n     *\n     * // stateName can be a single top-level name (must be unique).\n     * $stateProvider.state(\"home\", {});\n     *\n     * // Or it can be a nested state name. This state is a child of the \n     * // above \"home\" state.\n     * $stateProvider.state(\"home.newest\", {});\n     *\n     * // Nest states as deeply as needed.\n     * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n     *\n     * // state() returns $stateProvider, so you can chain state declarations.\n     * $stateProvider\n     *   .state(\"home\", {})\n     *   .state(\"about\", {})\n     *   .state(\"contacts\", {});\n     * </pre>\n     *\n     * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\". \n     * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n     * @param {object} definition State configuration object.\n     */\n    this.state = state;\n    function state(name, definition) {\n      /*jshint validthis: true */\n      if (isObject(name)) definition = name;else definition.name = name;\n      registerState(definition);\n      return this;\n    }\n\n    /**\n     * @ngdoc object\n     * @name ui.router.state.$state\n     *\n     * @requires $rootScope\n     * @requires $q\n     * @requires ui.router.state.$view\n     * @requires $injector\n     * @requires ui.router.util.$resolve\n     * @requires ui.router.state.$stateParams\n     * @requires ui.router.router.$urlRouter\n     *\n     * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n     * you'd like to test against the current active state.\n     * @property {object} current A reference to the state's config object. However \n     * you passed it in. Useful for accessing custom data.\n     * @property {object} transition Currently pending transition. A promise that'll \n     * resolve or reject.\n     *\n     * @description\n     * `$state` service is responsible for representing states as well as transitioning\n     * between them. It also provides interfaces to ask for current state or even states\n     * you're coming from.\n     */\n    this.$get = $get;\n    $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter'];\n    function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter) {\n\n      var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n      var TransitionPrevented = $q.reject(new Error('transition prevented'));\n      var TransitionAborted = $q.reject(new Error('transition aborted'));\n      var TransitionFailed = $q.reject(new Error('transition failed'));\n\n      // Handles the case where a state which is the target of a transition is not found, and the user\n      // can optionally retry or defer the transition\n      function handleRedirect(redirect, state, params, options) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateNotFound\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when a requested state **cannot be found** using the provided state name during transition.\n         * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n         * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n         * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n         * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n         * @param {State} fromState Current state object.\n         * @param {Object} fromParams Current state params.\n         *\n         * @example\n         *\n         * <pre>\n         * // somewhere, assume lazy.state has not been defined\n         * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n         *\n         * // somewhere else\n         * $scope.$on('$stateNotFound',\n         * function(event, unfoundState, fromState, fromParams){\n         *     console.log(unfoundState.to); // \"lazy.state\"\n         *     console.log(unfoundState.toParams); // {a:1, b:2}\n         *     console.log(unfoundState.options); // {inherit:false} + default options\n         * })\n         * </pre>\n         */\n        var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n        if (evt.defaultPrevented) {\n          $urlRouter.update();\n          return TransitionAborted;\n        }\n\n        if (!evt.retry) {\n          return null;\n        }\n\n        // Allow the handler to return a promise to defer state lookup retry\n        if (options.$retry) {\n          $urlRouter.update();\n          return TransitionFailed;\n        }\n        var retryTransition = $state.transition = $q.when(evt.retry);\n\n        retryTransition.then(function () {\n          if (retryTransition !== $state.transition) return TransitionSuperseded;\n          redirect.options.$retry = true;\n          return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n        }, function () {\n          return TransitionAborted;\n        });\n        $urlRouter.update();\n\n        return retryTransition;\n      }\n\n      root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n      $state = {\n        params: {},\n        current: root.self,\n        $current: root,\n        transition: null\n      };\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#reload\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired, \n       * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).\n       *\n       * @example\n       * <pre>\n       * var app angular.module('app', ['ui.router']);\n       *\n       * app.controller('ctrl', function ($scope, $state) {\n       *   $scope.reload = function(){\n       *     $state.reload();\n       *   }\n       * });\n       * </pre>\n       *\n       * `reload()` is just an alias for:\n       * <pre>\n       * $state.transitionTo($state.current, $stateParams, { \n       *   reload: true, inherit: false, notify: false \n       * });\n       * </pre>\n       */\n      $state.reload = (function () {\n        function reload() {\n          $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: false });\n        }\n\n        return reload;\n      })();\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#go\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * Convenience method for transitioning to a new state. `$state.go` calls \n       * `$state.transitionTo` internally but automatically sets options to \n       * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n       * This allows you to easily use an absolute or relative to path and specify \n       * only the parameters you'd like to update (while letting unspecified parameters \n       * inherit from the currently active ancestor states).\n       *\n       * @example\n       * <pre>\n       * var app = angular.module('app', ['ui.router']);\n       *\n       * app.controller('ctrl', function ($scope, $state) {\n       *   $scope.changeState = function () {\n       *     $state.go('contact.detail');\n       *   };\n       * });\n       * </pre>\n       * <img src='../ngdoc_assets/StateGoExamples.png'/>\n       *\n       * @param {string} to Absolute state name or relative state path. Some examples:\n       *\n       * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n       * - `$state.go('^')` - will go to a parent state\n       * - `$state.go('^.sibling')` - will go to a sibling state\n       * - `$state.go('.child.grandchild')` - will go to grandchild state\n       *\n       * @param {object=} params A map of the parameters that will be sent to the state, \n       * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n       * defined parameters. This allows, for example, going to a sibling state that shares parameters\n       * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n       * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n       * will get you all current parameters, etc.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n       *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n       * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n       * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n       *    defines which state to be relative from.\n       * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n       * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n       *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n       *    use this when you want to force a reload when *everything* is the same, including search params.\n       *\n       * @returns {promise} A promise representing the state of the new transition.\n       *\n       * Possible success values:\n       *\n       * - $state.current\n       *\n       * <br/>Possible rejection values:\n       *\n       * - 'transition superseded' - when a newer transition has been started after this one\n       * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n       * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n       *   when a `$stateNotFound` `event.retry` promise errors.\n       * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n       * - *resolve error* - when an error has occurred with a `resolve`\n       *\n       */\n      $state.go = (function () {\n        function go(to, params, options) {\n          return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n        }\n\n        return go;\n      })();\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#transitionTo\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n       * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n       *\n       * @example\n       * <pre>\n       * var app = angular.module('app', ['ui.router']);\n       *\n       * app.controller('ctrl', function ($scope, $state) {\n       *   $scope.changeState = function () {\n       *     $state.transitionTo('contact.detail');\n       *   };\n       * });\n       * </pre>\n       *\n       * @param {string} to State name.\n       * @param {object=} toParams A map of the parameters that will be sent to the state,\n       * will populate $stateParams.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n       *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n       * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n       * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n       *    defines which state to be relative from.\n       * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n       * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n       *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n       *    use this when you want to force a reload when *everything* is the same, including search params.\n       *\n       * @returns {promise} A promise representing the state of the new transition. See\n       * {@link ui.router.state.$state#methods_go $state.go}.\n       */\n      $state.transitionTo = (function () {\n        function transitionTo(to, toParams, options) {\n          toParams = toParams || {};\n          options = extend({\n            location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n          }, options || {});\n\n          var from = $state.$current,\n              fromParams = $state.params,\n              fromPath = from.path;\n          var evt,\n              toState = findState(to, options.relative);\n\n          if (!isDefined(toState)) {\n            var redirect = { to: to, toParams: toParams, options: options };\n            var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n            if (redirectResult) {\n              return redirectResult;\n            }\n\n            // Always retry once if the $stateNotFound was not prevented\n            // (handles either redirect changed or state lazy-definition)\n            to = redirect.to;\n            toParams = redirect.toParams;\n            options = redirect.options;\n            toState = findState(to, options.relative);\n\n            if (!isDefined(toState)) {\n              if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n              throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n            }\n          }\n          if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n          if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n          to = toState;\n\n          var toPath = to.path;\n\n          // Starting from the root of the path, keep all levels that haven't changed\n          var keep = 0,\n              state = toPath[keep],\n              locals = root.locals,\n              toLocals = [];\n\n          if (!options.reload) {\n            while (state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams)) {\n              locals = toLocals[keep] = state.locals;\n              keep++;\n              state = toPath[keep];\n            }\n          }\n\n          // If we're going to the same state and all locals are kept, we've got nothing to do.\n          // But clear 'transition', as we still want to cancel any other pending transitions.\n          // TODO: We may not want to bump 'transition' if we're called from a location change\n          // that we've initiated ourselves, because we might accidentally abort a legitimate\n          // transition initiated from code?\n          if (shouldTriggerReload(to, from, locals, options)) {\n            if (to.self.reloadOnSearch !== false) $urlRouter.update();\n            $state.transition = null;\n            return $q.when($state.current);\n          }\n\n          // Filter parameters before we pass them to event handlers etc.\n          toParams = filterByKeys(objectKeys(to.params), toParams || {});\n\n          // Broadcast start event and cancel the transition if requested\n          if (options.notify) {\n            /**\n             * @ngdoc event\n             * @name ui.router.state.$state#$stateChangeStart\n             * @eventOf ui.router.state.$state\n             * @eventType broadcast on root scope\n             * @description\n             * Fired when the state transition **begins**. You can use `event.preventDefault()`\n             * to prevent the transition from happening and then the transition promise will be\n             * rejected with a `'transition prevented'` value.\n             *\n             * @param {Object} event Event object.\n             * @param {State} toState The state being transitioned to.\n             * @param {Object} toParams The params supplied to the `toState`.\n             * @param {State} fromState The current state, pre-transition.\n             * @param {Object} fromParams The params supplied to the `fromState`.\n             *\n             * @example\n             *\n             * <pre>\n             * $rootScope.$on('$stateChangeStart',\n             * function(event, toState, toParams, fromState, fromParams){\n             *     event.preventDefault();\n             *     // transitionTo() promise will be rejected with\n             *     // a 'transition prevented' error\n             * })\n             * </pre>\n             */\n            if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n              $urlRouter.update();\n              return TransitionPrevented;\n            }\n          }\n\n          // Resolve locals for the remaining states, but don't update any global state just\n          // yet -- if anything fails to resolve the current state needs to remain untouched.\n          // We also set up an inheritance chain for the locals here. This allows the view directive\n          // to quickly look up the correct definition for each view in the current state. Even\n          // though we create the locals object itself outside resolveState(), it is initially\n          // empty and gets filled asynchronously. We need to keep track of the promise for the\n          // (fully resolved) current locals, and pass this down the chain.\n          var resolved = $q.when(locals);\n\n          for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n            locals = toLocals[l] = inherit(locals);\n            resolved = resolveState(state, toParams, state === to, resolved, locals);\n          }\n\n          // Once everything is resolved, we are ready to perform the actual transition\n          // and return a promise for the new state. We also keep track of what the\n          // current promise is, so that we can detect overlapping transitions and\n          // keep only the outcome of the last transition.\n          var transition = $state.transition = resolved.then(function () {\n            var l, entering, exiting;\n\n            if ($state.transition !== transition) return TransitionSuperseded;\n\n            // Exit 'from' states not kept\n            for (l = fromPath.length - 1; l >= keep; l--) {\n              exiting = fromPath[l];\n              if (exiting.self.onExit) {\n                $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n              }\n              exiting.locals = null;\n            }\n\n            // Enter 'to' states not kept\n            for (l = keep; l < toPath.length; l++) {\n              entering = toPath[l];\n              entering.locals = toLocals[l];\n              if (entering.self.onEnter) {\n                $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n              }\n            }\n\n            // Run it again, to catch any transitions in callbacks\n            if ($state.transition !== transition) return TransitionSuperseded;\n\n            // Update globals in $state\n            $state.$current = to;\n            $state.current = to.self;\n            $state.params = toParams;\n            copy($state.params, $stateParams);\n            $state.transition = null;\n\n            if (options.location && to.navigable) {\n              $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n                replace: options.location === 'replace'\n              });\n            }\n\n            if (options.notify) {\n              /**\n               * @ngdoc event\n               * @name ui.router.state.$state#$stateChangeSuccess\n               * @eventOf ui.router.state.$state\n               * @eventType broadcast on root scope\n               * @description\n               * Fired once the state transition is **complete**.\n               *\n               * @param {Object} event Event object.\n               * @param {State} toState The state being transitioned to.\n               * @param {Object} toParams The params supplied to the `toState`.\n               * @param {State} fromState The current state, pre-transition.\n               * @param {Object} fromParams The params supplied to the `fromState`.\n               */\n              $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n            }\n            $urlRouter.update(true);\n\n            return $state.current;\n          }, function (error) {\n            if ($state.transition !== transition) return TransitionSuperseded;\n\n            $state.transition = null;\n            /**\n             * @ngdoc event\n             * @name ui.router.state.$state#$stateChangeError\n             * @eventOf ui.router.state.$state\n             * @eventType broadcast on root scope\n             * @description\n             * Fired when an **error occurs** during transition. It's important to note that if you\n             * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n             * they will not throw traditionally. You must listen for this $stateChangeError event to\n             * catch **ALL** errors.\n             *\n             * @param {Object} event Event object.\n             * @param {State} toState The state being transitioned to.\n             * @param {Object} toParams The params supplied to the `toState`.\n             * @param {State} fromState The current state, pre-transition.\n             * @param {Object} fromParams The params supplied to the `fromState`.\n             * @param {Error} error The resolve error object.\n             */\n            evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n            if (!evt.defaultPrevented) {\n              $urlRouter.update();\n            }\n\n            return $q.reject(error);\n          });\n\n          return transition;\n        }\n\n        return transitionTo;\n      })();\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#is\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n       * but only checks for the full state name. If params is supplied then it will be \n       * tested for strict equality against the current active params object, so all params \n       * must match with none missing and no extras.\n       *\n       * @example\n       * <pre>\n       * $state.$current.name = 'contacts.details.item';\n       *\n       * // absolute name\n       * $state.is('contact.details.item'); // returns true\n       * $state.is(contactDetailItemStateObject); // returns true\n       *\n       * // relative name (. and ^), typically from a template\n       * // E.g. from the 'contacts.details' template\n       * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n       * </pre>\n       *\n       * @param {string|object} stateName The state name (absolute or relative) or state object you'd like to check.\n       * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like \n       * to test against the current active state.\n       * @returns {boolean} Returns true if it is the state.\n       */\n      $state.is = (function () {\n        function is(stateOrName, params) {\n          var state = findState(stateOrName);\n\n          if (!isDefined(state)) {\n            return undefined;\n          }\n\n          if ($state.$current !== state) {\n            return false;\n          }\n\n          return isDefined(params) && params !== null ? angular.equals($stateParams, params) : true;\n        }\n\n        return is;\n      })();\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#includes\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * A method to determine if the current active state is equal to or is the child of the\n       * state stateName. If any params are passed then they will be tested for a match as well.\n       * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n       *\n       * @example\n       * Partial and relative names\n       * <pre>\n       * $state.$current.name = 'contacts.details.item';\n       *\n       * // Using partial names\n       * $state.includes(\"contacts\"); // returns true\n       * $state.includes(\"contacts.details\"); // returns true\n       * $state.includes(\"contacts.details.item\"); // returns true\n       * $state.includes(\"contacts.list\"); // returns false\n       * $state.includes(\"about\"); // returns false\n       *\n       * // Using relative names (. and ^), typically from a template\n       * // E.g. from the 'contacts.details' template\n       * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n       * </pre>\n       *\n       * Basic globbing patterns\n       * <pre>\n       * $state.$current.name = 'contacts.details.item.url';\n       *\n       * $state.includes(\"*.details.*.*\"); // returns true\n       * $state.includes(\"*.details.**\"); // returns true\n       * $state.includes(\"**.item.**\"); // returns true\n       * $state.includes(\"*.details.item.url\"); // returns true\n       * $state.includes(\"*.details.*.url\"); // returns true\n       * $state.includes(\"*.details.*\"); // returns false\n       * $state.includes(\"item.**\"); // returns false\n       * </pre>\n       *\n       * @param {string} stateOrName A partial name, relative name, or glob pattern\n       * to be searched for within the current state name.\n       * @param {object} params A param object, e.g. `{sectionId: section.id}`,\n       * that you'd like to test against the current active state.\n       * @returns {boolean} Returns true if it does include the state\n       */\n      $state.includes = (function () {\n        function includes(stateOrName, params) {\n          if (isString(stateOrName) && isGlob(stateOrName)) {\n            if (!doesStateMatchGlob(stateOrName)) {\n              return false;\n            }\n            stateOrName = $state.$current.name;\n          }\n          var state = findState(stateOrName);\n\n          if (!isDefined(state)) {\n            return undefined;\n          }\n          if (!isDefined($state.$current.includes[state.name])) {\n            return false;\n          }\n          return equalForKeys(params, $stateParams);\n        }\n\n        return includes;\n      })();\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#href\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * A url generation method that returns the compiled url for the given state populated with the given params.\n       *\n       * @example\n       * <pre>\n       * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n       * </pre>\n       *\n       * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n       * @param {object=} params An object of parameter values to fill the state's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n       *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n       *    ancestor with a valid url).\n       * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n       * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n       *    defines which state to be relative from.\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       * \n       * @returns {string} compiled state url\n       */\n      $state.href = (function () {\n        function href(stateOrName, params, options) {\n          options = extend({\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: $state.$current\n          }, options || {});\n\n          var state = findState(stateOrName, options.relative);\n\n          if (!isDefined(state)) return null;\n          if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\n          var nav = state && options.lossy ? state.navigable : state;\n\n          if (!nav || !nav.url) {\n            return null;\n          }\n          return $urlRouter.href(nav.url, filterByKeys(objectKeys(state.params), params || {}), {\n            absolute: options.absolute\n          });\n        }\n\n        return href;\n      })();\n\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$state#get\n       * @methodOf ui.router.state.$state\n       *\n       * @description\n       * Returns the state configuration object for any specific state or all states.\n       *\n       * @param {string|Sbject=} stateOrName (absolute or relative) If provided, will only get the config for\n       * the requested state. If not provided, returns an array of ALL state configs.\n       * @returns {Object|Array} State configuration object or array of all objects.\n       */\n      $state.get = function (stateOrName, context) {\n        if (arguments.length === 0) return objectKeys(states).map(function (name) {\n          return states[name].self;\n        });\n        var state = findState(stateOrName, context);\n        return state && state.self ? state.self : null;\n      };\n\n      function resolveState(state, params, paramsAreFiltered, inherited, dst) {\n        // Make a restricted $stateParams with only the parameters that apply to this state if\n        // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n        // we also need $stateParams to be available for any $injector calls we make during the\n        // dependency resolution process.\n        var $stateParams = paramsAreFiltered ? params : filterByKeys(objectKeys(state.params), params);\n        var locals = { $stateParams: $stateParams };\n\n        // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n        // We're also including $stateParams in this; that way the parameters are restricted\n        // to the set that should be visible to the state, and are independent of when we update\n        // the global $state and $stateParams values.\n        dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n        var promises = [dst.resolve.then(function (globals) {\n          dst.globals = globals;\n        })];\n        if (inherited) promises.push(inherited);\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};\n          injectables.$template = [function () {\n            return $view.load(name, { view: view, locals: locals, params: $stateParams }) || '';\n          }];\n\n          promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, locals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        // Wait for all the promises and then return the activation object\n        return $q.all(promises).then(function (values) {\n          return dst;\n        });\n      }\n\n      return $state;\n    }\n\n    function shouldTriggerReload(to, from, locals, options) {\n      if (to === from && (locals === from.locals && !options.reload || to.self.reloadOnSearch === false)) {\n        return true;\n      }\n    }\n  }\n\n  angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);\n\n  $ViewProvider.$inject = [];\n  function $ViewProvider() {\n\n    this.$get = $get;\n    /**\n     * @ngdoc object\n     * @name ui.router.state.$view\n     *\n     * @requires ui.router.util.$templateFactory\n     * @requires $rootScope\n     *\n     * @description\n     *\n     */\n    $get.$inject = ['$rootScope', '$templateFactory'];\n    function $get($rootScope, $templateFactory) {\n      return {\n        // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n        /**\n         * @ngdoc function\n         * @name ui.router.state.$view#load\n         * @methodOf ui.router.state.$view\n         *\n         * @description\n         *\n         * @param {string} name name\n         * @param {object} options option object.\n         */\n        load: (function () {\n          function load(name, options) {\n            var result,\n                defaults = {\n              template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n            };\n            options = extend(defaults, options);\n\n            if (options.view) {\n              result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n            }\n            if (result && options.notify) {\n              /**\n               * @ngdoc event\n               * @name ui.router.state.$state#$viewContentLoading\n               * @eventOf ui.router.state.$view\n               * @eventType broadcast on root scope\n               * @description\n               *\n               * Fired once the view **begins loading**, *before* the DOM is rendered.\n               *\n               * @param {Object} event Event object.\n               * @param {Object} viewConfig The view config properties (template, controller, etc).\n               *\n               * @example\n               *\n               * <pre>\n               * $scope.$on('$viewContentLoading',\n               * function(event, viewConfig){\n               *     // Access to all the view config properties.\n               *     // and one special property 'targetView'\n               *     // viewConfig.targetView\n               * });\n               * </pre>\n               */\n              $rootScope.$broadcast('$viewContentLoading', options);\n            }\n            return result;\n          }\n\n          return load;\n        })()\n      };\n    }\n  }\n\n  angular.module('ui.router.state').provider('$view', $ViewProvider);\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n   */\n  function $ViewScrollProvider() {\n\n    var useAnchorScroll = false;\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n     * @methodOf ui.router.state.$uiViewScrollProvider\n     *\n     * @description\n     * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n     * scrolling based on the url anchor.\n     */\n    this.useAnchorScroll = function () {\n      useAnchorScroll = true;\n    };\n\n    /**\n     * @ngdoc object\n     * @name ui.router.state.$uiViewScroll\n     *\n     * @requires $anchorScroll\n     * @requires $timeout\n     *\n     * @description\n     * When called with a jqLite element, it scrolls the element into view (after a\n     * `$timeout` so the DOM has time to refresh).\n     *\n     * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n     * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n     */\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n      if (useAnchorScroll) {\n        return $anchorScroll;\n      }\n\n      return function ($element) {\n        $timeout(function () {\n          $element[0].scrollIntoView();\n        }, 0, false);\n      };\n    }];\n  }\n\n  angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n  /**\n   * @ngdoc directive\n   * @name ui.router.state.directive:ui-view\n   *\n   * @requires ui.router.state.$state\n   * @requires $compile\n   * @requires $controller\n   * @requires $injector\n   * @requires ui.router.state.$uiViewScroll\n   * @requires $document\n   *\n   * @restrict ECA\n   *\n   * @description\n   * The ui-view directive tells $state where to place your templates.\n   *\n   * @param {string=} ui-view A view name. The name should be unique amongst the other views in the\n   * same state. You can have views of the same name that live in different states.\n   *\n   * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n   * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n   * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n   * scroll ui-view elements into view when they are populated during a state activation.\n   *\n   * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n   * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n   *\n   * @param {string=} onload Expression to evaluate whenever the view updates.\n   * \n   * @example\n   * A view can be unnamed or named. \n   * <pre>\n   * <!-- Unnamed -->\n   * <div ui-view></div> \n   * \n   * <!-- Named -->\n   * <div ui-view=\"viewName\"></div>\n   * </pre>\n   *\n   * You can only have one unnamed view within any template (or root html). If you are only using a \n   * single view and it is unnamed then you can populate it like so:\n   * <pre>\n   * <div ui-view></div> \n   * $stateProvider.state(\"home\", {\n   *   template: \"<h1>HELLO!</h1>\"\n   * })\n   * </pre>\n   * \n   * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n   * config property, by name, in this case an empty name:\n   * <pre>\n   * $stateProvider.state(\"home\", {\n   *   views: {\n   *     \"\": {\n   *       template: \"<h1>HELLO!</h1>\"\n   *     }\n   *   }    \n   * })\n   * </pre>\n   * \n   * But typically you'll only use the views property if you name your view or have more than one view \n   * in the same template. There's not really a compelling reason to name a view if its the only one, \n   * but you could if you wanted, like so:\n   * <pre>\n   * <div ui-view=\"main\"></div>\n   * </pre> \n   * <pre>\n   * $stateProvider.state(\"home\", {\n   *   views: {\n   *     \"main\": {\n   *       template: \"<h1>HELLO!</h1>\"\n   *     }\n   *   }    \n   * })\n   * </pre>\n   * \n   * Really though, you'll use views to set up multiple views:\n   * <pre>\n   * <div ui-view></div>\n   * <div ui-view=\"chart\"></div> \n   * <div ui-view=\"data\"></div> \n   * </pre>\n   * \n   * <pre>\n   * $stateProvider.state(\"home\", {\n   *   views: {\n   *     \"\": {\n   *       template: \"<h1>HELLO!</h1>\"\n   *     },\n   *     \"chart\": {\n   *       template: \"<chart_thing/>\"\n   *     },\n   *     \"data\": {\n   *       template: \"<data_thing/>\"\n   *     }\n   *   }    \n   * })\n   * </pre>\n   *\n   * Examples for `autoscroll`:\n   *\n   * <pre>\n   * <!-- If autoscroll present with no expression,\n   *      then scroll ui-view into view -->\n   * <ui-view autoscroll/>\n   *\n   * <!-- If autoscroll present with valid expression,\n   *      then scroll ui-view into view if expression evaluates to true -->\n   * <ui-view autoscroll='true'/>\n   * <ui-view autoscroll='false'/>\n   * <ui-view autoscroll='scopeVariable'/>\n   * </pre>\n   */\n  $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll'];\n  function $ViewDirective($state, $injector, $uiViewScroll) {\n\n    function getService() {\n      return $injector.has ? function (service) {\n        return $injector.has(service) ? $injector.get(service) : null;\n      } : function (service) {\n        try {\n          return $injector.get(service);\n        } catch (e) {\n          return null;\n        }\n      };\n    }\n\n    var service = getService(),\n        $animator = service('$animator'),\n        $animate = service('$animate');\n\n    // Returns a set of DOM manipulation functions based on which Angular version\n    // it should use\n    function getRenderer(attrs, scope) {\n      var statics = function () {\n        return {\n          enter: function (element, target, cb) {\n            target.after(element);cb();\n          },\n          leave: function (element, cb) {\n            element.remove();cb();\n          }\n        };\n      };\n\n      if ($animate) {\n        return {\n          enter: function (element, target, cb) {\n            $animate.enter(element, null, target, cb);\n          },\n          leave: function (element, cb) {\n            $animate.leave(element, cb);\n          }\n        };\n      }\n\n      if ($animator) {\n        var animate = $animator && $animator(scope, attrs);\n\n        return {\n          enter: function (element, target, cb) {\n            animate.enter(element, null, target);cb();\n          },\n          leave: function (element, cb) {\n            animate.leave(element);cb();\n          }\n        };\n      }\n\n      return statics();\n    }\n\n    var directive = {\n      restrict: 'ECA',\n      terminal: true,\n      priority: 400,\n      transclude: 'element',\n      compile: function (tElement, tAttrs, $transclude) {\n        return function (scope, $element, attrs) {\n          var previousEl,\n              currentEl,\n              currentScope,\n              latestLocals,\n              onloadExp = attrs.onload || '',\n              autoScrollExp = attrs.autoscroll,\n              renderer = getRenderer(attrs, scope);\n\n          scope.$on('$stateChangeSuccess', function () {\n            updateView(false);\n          });\n          scope.$on('$viewContentLoading', function () {\n            updateView(false);\n          });\n\n          updateView(true);\n\n          function cleanupLastView() {\n            if (previousEl) {\n              previousEl.remove();\n              previousEl = null;\n            }\n\n            if (currentScope) {\n              currentScope.$destroy();\n              currentScope = null;\n            }\n\n            if (currentEl) {\n              renderer.leave(currentEl, function () {\n                previousEl = null;\n              });\n\n              previousEl = currentEl;\n              currentEl = null;\n            }\n          }\n\n          function updateView(firstTime) {\n            var newScope,\n                name = getUiViewName(attrs, $element.inheritedData('$uiView')),\n                previousLocals = name && $state.$current && $state.$current.locals[name];\n\n            if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n            newScope = scope.$new();\n            latestLocals = $state.$current.locals[name];\n\n            var clone = $transclude(newScope, function (clone) {\n              renderer.enter(clone, $element, (function () {\n                function onUiViewEnter() {\n                  if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                    $uiViewScroll(clone);\n                  }\n                }\n\n                return onUiViewEnter;\n              })());\n              cleanupLastView();\n            });\n\n            currentEl = clone;\n            currentScope = newScope;\n            /**\n             * @ngdoc event\n             * @name ui.router.state.directive:ui-view#$viewContentLoaded\n             * @eventOf ui.router.state.directive:ui-view\n             * @eventType emits on ui-view directive scope\n             * @description           *\n             * Fired once the view is **loaded**, *after* the DOM is rendered.\n             *\n             * @param {Object} event Event object.\n             */\n            currentScope.$emit('$viewContentLoaded');\n            currentScope.$eval(onloadExp);\n          }\n        };\n      }\n    };\n\n    return directive;\n  }\n\n  $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state'];\n  function $ViewDirectiveFill($compile, $controller, $state) {\n    return {\n      restrict: 'ECA',\n      priority: -400,\n      compile: function (tElement) {\n        var initial = tElement.html();\n        return function (scope, $element, attrs) {\n          var current = $state.$current,\n              name = getUiViewName(attrs, $element.inheritedData('$uiView')),\n              locals = current && current.locals[name];\n\n          if (!locals) {\n            return;\n          }\n\n          $element.data('$uiView', { name: name, state: locals.$$state });\n          $element.html(locals.$template ? locals.$template : initial);\n\n          var link = $compile($element.contents());\n\n          if (locals.$$controller) {\n            locals.$scope = scope;\n            var controller = $controller(locals.$$controller, locals);\n            if (locals.$$controllerAs) {\n              scope[locals.$$controllerAs] = controller;\n            }\n            $element.data('$ngControllerController', controller);\n            $element.children().data('$ngControllerController', controller);\n          }\n\n          link(scope);\n        };\n      }\n    };\n  }\n\n  /**\n   * Shared ui-view code for both directives:\n   * Given attributes and inherited $uiView data, return the view's name\n   */\n  function getUiViewName(attrs, inherited) {\n    var name = attrs.uiView || attrs.name || '';\n    return name.indexOf('@') >= 0 ? name : name + '@' + (inherited ? inherited.state.name : '');\n  }\n\n  angular.module('ui.router.state').directive('uiView', $ViewDirective);\n  angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\n  function parseStateRef(ref, current) {\n    var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/),\n        parsed;\n    if (preparsed) ref = current + '(' + preparsed[1] + ')';\n    parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n    if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1], paramExpr: parsed[3] || null };\n  }\n\n  function stateContext(el) {\n    var stateData = el.parent().inheritedData('$uiView');\n\n    if (stateData && stateData.state && stateData.state.name) {\n      return stateData.state;\n    }\n  }\n\n  /**\n   * @ngdoc directive\n   * @name ui.router.state.directive:ui-sref\n   *\n   * @requires ui.router.state.$state\n   * @requires $timeout\n   *\n   * @restrict A\n   *\n   * @description\n   * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n   * URL, the directive will automatically generate & update the `href` attribute via \n   * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n   * the link will trigger a state transition with optional parameters. \n   *\n   * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n   * handled natively by the browser.\n   *\n   * You can also use relative state paths within ui-sref, just like the relative \n   * paths passed to `$state.go()`. You just need to be aware that the path is relative\n   * to the state that the link lives in, in other words the state that loaded the \n   * template containing the link.\n   *\n   * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n   * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n   * and `reload`.\n   *\n   * @example\n   * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n   * following template:\n   * <pre>\n   * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n   * \n   * <ul>\n   *     <li ng-repeat=\"contact in contacts\">\n   *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n   *     </li>\n   * </ul>\n   * </pre>\n   * \n   * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n   * <pre>\n   * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n   * \n   * <ul>\n   *     <li ng-repeat=\"contact in contacts\">\n   *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n   *     </li>\n   *     <li ng-repeat=\"contact in contacts\">\n   *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n   *     </li>\n   *     <li ng-repeat=\"contact in contacts\">\n   *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n   *     </li>\n   * </ul>\n   *\n   * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n   * </pre>\n   *\n   * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n   * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n   */\n  $StateRefDirective.$inject = ['$state', '$timeout'];\n  function $StateRefDirective($state, $timeout) {\n    var allowedOptions = ['location', 'inherit', 'reload'];\n\n    return {\n      restrict: 'A',\n      require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n      link: function (scope, element, attrs, uiSrefActive) {\n        var ref = parseStateRef(attrs.uiSref, $state.current.name);\n        var params = null,\n            url = null,\n            base = stateContext(element) || $state.$current;\n        var isForm = element[0].nodeName === \"FORM\";\n        var attr = isForm ? \"action\" : \"href\",\n            nav = true;\n\n        var options = { relative: base, inherit: true };\n        var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n        angular.forEach(allowedOptions, function (option) {\n          if (option in optionsOverride) {\n            options[option] = optionsOverride[option];\n          }\n        });\n\n        var update = function (newVal) {\n          if (newVal) params = newVal;\n          if (!nav) return;\n\n          var newHref = $state.href(ref.state, params, options);\n\n          var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n          if (activeDirective) {\n            activeDirective.$$setStateInfo(ref.state, params);\n          }\n          if (newHref === null) {\n            nav = false;\n            return false;\n          }\n          element[0][attr] = newHref;\n        };\n\n        if (ref.paramExpr) {\n          scope.$watch(ref.paramExpr, function (newVal, oldVal) {\n            if (newVal !== params) update(newVal);\n          }, true);\n          params = scope.$eval(ref.paramExpr);\n        }\n        update();\n\n        if (isForm) return;\n\n        element.bind(\"click\", function (e) {\n          var button = e.which || e.button;\n          if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition = $timeout(function () {\n              $state.go(ref.state, params, options);\n            });\n            e.preventDefault();\n\n            e.preventDefault = function () {\n              $timeout.cancel(transition);\n            };\n          }\n        });\n      }\n    };\n  }\n\n  /**\n   * @ngdoc directive\n   * @name ui.router.state.directive:ui-sref-active\n   *\n   * @requires ui.router.state.$state\n   * @requires ui.router.state.$stateParams\n   * @requires $interpolate\n   *\n   * @restrict A\n   *\n   * @description\n   * A directive working alongside ui-sref to add classes to an element when the\n   * related ui-sref directive's state is active, and removing them when it is inactive.\n   * The primary use-case is to simplify the special appearance of navigation menus\n   * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n   * distinguishing it from the inactive menu items.\n   *\n   * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n   * ui-sref-active found at the same level or above the ui-sref will be used.\n   *\n   * Will activate when the ui-sref's target state or any child state is active. If you\n   * need to activate only when the ui-sref target state is active and *not* any of\n   * it's children, then you will use\n   * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n   *\n   * @example\n   * Given the following template:\n   * <pre>\n   * <ul>\n   *   <li ui-sref-active=\"active\" class=\"item\">\n   *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n   *   </li>\n   * </ul>\n   * </pre>\n   *\n   *\n   * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n   * the resulting HTML will appear as (note the 'active' class):\n   * <pre>\n   * <ul>\n   *   <li ui-sref-active=\"active\" class=\"item active\">\n   *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n   *   </li>\n   * </ul>\n   * </pre>\n   *\n   * The class name is interpolated **once** during the directives link time (any further changes to the\n   * interpolated value are ignored).\n   *\n   * Multiple classes may be specified in a space-separated format:\n   * <pre>\n   * <ul>\n   *   <li ui-sref-active='class1 class2 class3'>\n   *     <a ui-sref=\"app.user\">link</a>\n   *   </li>\n   * </ul>\n   * </pre>\n   */\n\n  /**\n   * @ngdoc directive\n   * @name ui.router.state.directive:ui-sref-active-eq\n   *\n   * @requires ui.router.state.$state\n   * @requires ui.router.state.$stateParams\n   * @requires $interpolate\n   *\n   * @restrict A\n   *\n   * @description\n   * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will will only activate\n   * when the exact target state used in the `ui-sref` is active; no child states.\n   *\n   */\n  $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n  function $StateRefActiveDirective($state, $stateParams, $interpolate) {\n    return {\n      restrict: \"A\",\n      controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n        var state, params, activeClass;\n\n        // There probably isn't much point in $observing this\n        // uiSrefActive and uiSrefActiveEq share the same directive object with some\n        // slight difference in logic routing\n        activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n        // Allow uiSref to communicate with uiSrefActive[Equals]\n        this.$$setStateInfo = function (newState, newParams) {\n          state = $state.get(newState, stateContext($element));\n          params = newParams;\n          update();\n        };\n\n        $scope.$on('$stateChangeSuccess', update);\n\n        // Update route state\n        function update() {\n          if (isMatch()) {\n            $element.addClass(activeClass);\n          } else {\n            $element.removeClass(activeClass);\n          }\n        }\n\n        function isMatch() {\n          if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n            return $state.$current.self === state && matchesParams();\n          } else {\n            return $state.includes(state.name) && matchesParams();\n          }\n        }\n\n        function matchesParams() {\n          return !params || equalForKeys(params, $stateParams);\n        }\n      }]\n    };\n  }\n\n  angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n  /**\n   * @ngdoc filter\n   * @name ui.router.state.filter:isState\n   *\n   * @requires ui.router.state.$state\n   *\n   * @description\n   * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n   */\n  $IsStateFilter.$inject = ['$state'];\n  function $IsStateFilter($state) {\n    return function (state) {\n      return $state.is(state);\n    };\n  }\n\n  /**\n   * @ngdoc filter\n   * @name ui.router.state.filter:includedByState\n   *\n   * @requires ui.router.state.$state\n   *\n   * @description\n   * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n   */\n  $IncludedByStateFilter.$inject = ['$state'];\n  function $IncludedByStateFilter($state) {\n    return function (state) {\n      return $state.includes(state);\n    };\n  }\n\n  angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);","ast":null,"map":{"version":3,"sources":["/client/angular/ui-router/angular-ui-router.js"],"names":[],"mappings":"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","file":"/client/angular/ui-router/angular-ui-router.js.map","sourcesContent":["/**\n * State-based routing for AngularJS\n * @version v0.2.11\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  angular.forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction arraySearch(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (arraySearch(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, cycle.indexOf(key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n      \n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, parent.$$inheritedValues);\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      if (parent.$$values) {\n        merged = merge(values, parent.$$values);\n        result.$$inheritedValues = parent.$$values;\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = parent.$$inheritedValues;\n        }        \n        extend(promises, parent.$$promises);\n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache })\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n * \n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp '}'` - curly placeholder with regexp. Should the regexp itself contain\n *   curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon \n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n * \n * Examples:\n * \n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when \n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config) {\n  config = angular.isObject(config) ? config : {};\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])(\\w+)               classic placeholder ($1 / $2)\n  //    \\{(\\w+)(?:\\:( ... ))?\\}   curly brace placeholder ($3) with optional regexp ... ($4)\n  //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                  - anything other than curly braces or backslash\n  //    \\\\.                       - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}     - a matched set of curly braces containing other atoms\n  var placeholder = /([:*])(\\w+)|\\{(\\w+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      params = this.params = {};\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n  function $value(value) {\n    /*jshint validthis: true */\n    return isDefined(value) ? this.type.decode(value) : $UrlMatcherFactory.$$getDefaultValue(this);\n  }\n\n  function addParameter(id, type, config) {\n    if (!/^\\w+(-+\\w+)*$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = extend({ type: type || new Type(), $value: $value }, config);\n  }\n\n  function quoteRegExp(string, pattern, isOptional) {\n    var result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    var flag = isOptional ? '?' : '';\n    return result + flag + '(' + pattern + ')' + flag;\n  }\n\n  function paramConfig(param) {\n    if (!config.params || !config.params[param]) return {};\n    var cfg = config.params[param];\n    return isObject(cfg) ? cfg : { value: cfg };\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  var id, regexp, segment, type, cfg;\n\n  while ((m = placeholder.exec(pattern))) {\n    id      = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    regexp  = m[4] || (m[1] == '*' ? '.*' : '[^/]*');\n    segment = pattern.substring(last, m.index);\n    type    = this.$types[regexp] || new Type({ pattern: new RegExp(regexp) });\n    cfg     = paramConfig(id);\n\n    if (segment.indexOf('?') >= 0) break; // we're into the search part\n\n    compiled += quoteRegExp(segment, type.$subPattern(), isDefined(cfg.value));\n    addParameter(id, type, cfg);\n    segments.push(segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    // Allow parameters to be separated by '?' as well as '&' to make concat() easier\n    forEach(search.substring(1).split(/[&?]/), function(key) {\n      addParameter(key, null, paramConfig(key));\n    });\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, config);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var params = this.parameters(), nTotal = params.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, cfg, param;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  for (i = 0; i < nPath; i++) {\n    param = params[i];\n    cfg = this.params[param];\n    values[param] = cfg.$value(m[i + 1]);\n  }\n  for (/**/; i < nTotal; i++) {\n    param = params[i];\n    cfg = this.params[param];\n    values[param] = cfg.$value(searchParams[param]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n * \n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return objectKeys(this.params);\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  var result = true, isOptional, cfg, self = this;\n\n  forEach(params, function(val, key) {\n    if (!self.params[key]) return;\n    cfg = self.params[key];\n    isOptional = !val && isDefined(cfg.value);\n    result = result && (isOptional || cfg.type.is(val));\n  });\n  return result;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  var segments = this.segments, params = this.parameters();\n\n  if (!values) return segments.join('').replace('//', '/');\n\n  var nPath = segments.length - 1, nTotal = params.length,\n    result = segments[0], i, search, value, param, cfg, array;\n\n  if (!this.validates(values)) return null;\n\n  for (i = 0; i < nPath; i++) {\n    param = params[i];\n    value = values[param];\n    cfg   = this.params[param];\n\n    if (!isDefined(value) && (segments[i] === '/' || segments[i + 1] === '/')) continue;\n    if (value != null) result += encodeURIComponent(cfg.type.encode(value));\n    result += segments[i + 1];\n  }\n\n  for (/**/; i < nTotal; i++) {\n    param = params[i];\n    value = values[param];\n    if (value == null) continue;\n    array = isArray(value);\n\n    if (array) {\n      value = value.map(encodeURIComponent).join('&' + param + '=');\n    }\n    result += (search ? '&' : '?') + param + '=' + (array ? value : encodeURIComponent(value));\n    search = true;\n  }\n  return result;\n};\n\nUrlMatcher.prototype.$types = {};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object hash that includes any method in `Type`'s public\n *        interface, and/or `pattern`, which should contain a custom regular expression used to match\n *        string parameters originating from a URL.\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a string URL parameter value to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n\n  var isCaseInsensitive = false, isStrictMode = true;\n\n  var enqueue = true, typeQueue = [], injector, defaultTypes = {\n    int: {\n      decode: function(val) {\n        return parseInt(val, 10);\n      },\n      is: function(val) {\n        if (!isDefined(val)) return false;\n        return this.decode(val.toString()) === val;\n      },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) {\n        return val ? 1 : 0;\n      },\n      decode: function(val) {\n        return parseInt(val, 10) === 0 ? false : true;\n      },\n      is: function(val) {\n        return val === true || val === false;\n      },\n      pattern: /0|1/\n    },\n    string: {\n      pattern: /[^\\/]*/\n    },\n    date: {\n      equals: function (a, b) {\n        return a.toISOString() === b.toISOString();\n      },\n      decode: function (val) {\n        return new Date(val);\n      },\n      encode: function (val) {\n        return [\n          val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   */\n  this.caseInsensitive = function(value) {\n    isCaseInsensitive = value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean} value `false` to match trailing slashes in URLs, otherwise `true`.\n   */\n  this.strictMode = function(value) {\n    isStrictMode = value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *   \n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} def  The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, def) {\n    if (!isDefined(def)) return UrlMatcher.prototype.$types[name];\n    typeQueue.push({ name: name, def: def });\n    if (!enqueue) flushTypeQueue();\n    return this;\n  };\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    UrlMatcher.prototype.$types = {};\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!UrlMatcher.prototype.$types[name]) UrlMatcher.prototype.$types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  // To ensure proper order of operations in object configuration, and to allow internal\n  // types to be overridden, `flushTypeQueue()` waits until `$urlMatcherFactory` is injected\n  // before actually wiring up and assigning type definitions\n  function flushTypeQueue() {\n    forEach(typeQueue, function(type) {\n      if (UrlMatcher.prototype.$types[type.name]) {\n        throw new Error(\"A type named '\" + type.name + \"' has already been defined.\");\n      }\n      var def = new Type(isInjectable(type.def) ? injector.invoke(type.def) : type.def);\n      UrlMatcher.prototype.$types[type.name] = def;\n    });\n  }\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {object} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. if handle is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|object} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\n    var baseHref = $browser.baseHref(), location = $location.url();\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n        $location.url(urlMatcher.format(params || {}));\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      if (!state.params) {\n        return state.url ? state.url.params : state.parent.params;\n      }\n      return state.params;\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    ownParams: function(state) {\n      state.params = state.params || {};\n\n      if (!state.parent) {\n          return objectKeys(state.params);\n      }\n      var paramNames = {}; forEach(state.params, function (v, k) { paramNames[k] = true; });\n\n      forEach(state.parent.params, function (v, k) {\n        if (!paramNames[k]) {\n          throw new Error(\"Missing required parameter '\" + k + \"' in state '\" + state.name + \"'\");\n        }\n        paramNames[k] = false;\n      });\n      var ownParams = [];\n\n      forEach(paramNames, function (own, p) {\n        if (own) ownParams.push(p);\n      });\n      return ownParams;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    if (queue[name]) {\n      for (var i = 0; i < queue[name].length; i++) {\n        registerState(queue[name][i]);\n      }\n    }\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(segments.indexOf(globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * <a id='template'></a>\n   *\n   * - **`template`** - {string|function=} - html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <a id='templateUrl'></a>\n   *\n   * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html \n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <a id='templateProvider'></a>\n   *\n   * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n   *   string.\n   *\n   * <a id='controller'></a>\n   *\n   * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly \n   *   related scope or the name of a registered controller if passed as a string.\n   *\n   * <a id='controllerProvider'></a>\n   *\n   * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n   *   the actual controller or string.\n   *\n   * <a id='controllerAs'></a>\n   * \n   * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be \n   *   published to scope under the controllerAs name.\n   *\n   * <a id='resolve'></a>\n   *\n   * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which \n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved or one to be rejected before the \n   *   controller is instantiated. If all the promises are resolved successfully, the values \n   *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any \n   *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <a id='url'></a>\n   *\n   * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   * <a id='params'></a>\n   *\n   * - **`params`** - {object=} - An array of parameter names or regular expressions. Only \n   *   use this within a state if you are not using url. Otherwise you can specify your\n   *   parameters within the url. When a state is navigated or transitioned to, the \n   *   $stateParams service will be populated with any parameters that were passed.\n   *\n   * <a id='views'></a>\n   *\n   * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n   *   manually/explicitly.\n   *\n   * <a id='abstract'></a>\n   *\n   * - **`abstract`** - {boolean=} - An abstract state will never be directly activated, \n   *   but can provide inherited properties to its common children states.\n   *\n   * <a id='onEnter'></a>\n   *\n   * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n   *\n   * <a id='onExit'></a>\n   *\n   * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n   *\n   * <a id='reloadOnSearch'></a>\n   *\n   * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state \n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   *\n   * <a id='data'></a>\n   *\n   * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the \n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\". \n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} definition State configuration object.\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired, \n     * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: false \n     * });\n     * </pre>\n     */\n    $state.reload = function reload() {\n      $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: false });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldTriggerReload(to, from, locals, options)) {\n        if (to.self.reloadOnSearch !== false) $urlRouter.update();\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(objectKeys(to.params), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be \n     * tested for strict equality against the current active params object, so all params \n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like \n     * to test against the current active state.\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params) {\n      var state = findState(stateOrName);\n\n      if (!isDefined(state)) {\n        return undefined;\n      }\n\n      if ($state.$current !== state) {\n        return false;\n      }\n\n      return isDefined(params) && params !== null ? angular.equals($stateParams, params) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params) {\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n      var state = findState(stateOrName);\n\n      if (!isDefined(state)) {\n        return undefined;\n      }\n      if (!isDefined($state.$current.includes[state.name])) {\n        return false;\n      }\n      return equalForKeys(params, $stateParams);\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || !nav.url) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(objectKeys(state.params), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|Sbject=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return objectKeys(states).map(function(name) { return states[name].self; });\n      var state = findState(stateOrName, context);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(objectKeys(state.params), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      // Resolve template and dependencies for all views.\n      forEach(state.views, function (view, name) {\n        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n        injectables.$template = [ function () {\n          return $view.load(name, { view: view, locals: locals, params: $stateParams }) || '';\n        }];\n\n        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {\n          // References to the controller (only instantiated at link time)\n          if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n            var injectLocals = angular.extend({}, injectables, locals);\n            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n          } else {\n            result.$$controller = view.controller;\n          }\n          // Provide access to the state itself for internal use\n          result.$$state = state;\n          result.$$controllerAs = view.controllerAs;\n          dst[name] = result;\n        }));\n      });\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldTriggerReload(to, from, locals, options) {\n    if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        if (result && options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$viewContentLoading\n         * @eventOf ui.router.state.$view\n         * @eventType broadcast on root scope\n         * @description\n         *\n         * Fired once the view **begins loading**, *before* the DOM is rendered.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} viewConfig The view config properties (template, controller, etc).\n         *\n         * @example\n         *\n         * <pre>\n         * $scope.$on('$viewContentLoading',\n         * function(event, viewConfig){\n         *     // Access to all the view config properties.\n         *     // and one special property 'targetView'\n         *     // viewConfig.targetView\n         * });\n         * </pre>\n         */\n          $rootScope.$broadcast('$viewContentLoading', options);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} ui-view A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) { $animate.enter(element, null, target, cb); },\n        leave: function(element, cb) { $animate.leave(element, cb); }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(attrs, $element.inheritedData('$uiView')),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded');\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state'];\nfunction $ViewDirectiveFill ($compile, $controller, $state) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(attrs, $element.inheritedData('$uiView')),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given attributes and inherited $uiView data, return the view's name\n */\nfunction getUiViewName(attrs, inherited) {\n  var name = attrs.uiView || attrs.name || '';\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n * URL, the directive will automatically generate & update the `href` attribute via \n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n * the link will trigger a state transition with optional parameters. \n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative \n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the \n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n * \n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  var allowedOptions = ['location', 'inherit', 'reload'];\n\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n      var params = null, url = null, base = stateContext(element) || $state.$current;\n      var isForm = element[0].nodeName === \"FORM\";\n      var attr = isForm ? \"action\" : \"href\", nav = true;\n\n      var options = { relative: base, inherit: true };\n      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n      angular.forEach(allowedOptions, function(option) {\n        if (option in optionsOverride) {\n          options[option] = optionsOverride[option];\n        }\n      });\n\n      var update = function(newVal) {\n        if (newVal) params = newVal;\n        if (!nav) return;\n\n        var newHref = $state.href(ref.state, params, options);\n\n        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n        if (activeDirective) {\n          activeDirective.$$setStateInfo(ref.state, params);\n        }\n        if (newHref === null) {\n          nav = false;\n          return false;\n        }\n        element[0][attr] = newHref;\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n          if (newVal !== params) update(newVal);\n        }, true);\n        params = scope.$eval(ref.paramExpr);\n      }\n      update();\n\n      if (isForm) return;\n\n      element.bind(\"click\", function(e) {\n        var button = e.which || e.button;\n        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n          var transition = $timeout(function() {\n            $state.go(ref.state, params, options);\n          });\n          e.preventDefault();\n\n          e.preventDefault = function() {\n            $timeout.cancel(transition);\n          };\n        }\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n      var state, params, activeClass;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$setStateInfo = function (newState, newParams) {\n        state = $state.get(newState, stateContext($element));\n        params = newParams;\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      // Update route state\n      function update() {\n        if (isMatch()) {\n          $element.addClass(activeClass);\n        } else {\n          $element.removeClass(activeClass);\n        }\n      }\n\n      function isMatch() {\n        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n          return $state.$current.self === state && matchesParams();\n        } else {\n          return $state.includes(state.name) && matchesParams();\n        }\n      }\n\n      function matchesParams() {\n        return !params || equalForKeys(params, $stateParams);\n      }\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  return function(state) {\n    return $state.is(state);\n  };\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  return function(state) {\n    return $state.includes(state);\n  };\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n"]},"hash":"e712900fa28bee13b413434581248bee255c4565"}
