{"version":3,"sources":["meteor://ðŸ’»app/packages/angular/lib/diff-array.js","meteor://ðŸ’»app/packages/angular/lib/get-updates.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-subscribe.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-stopper.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-collection.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-object.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-user.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-methods.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-session.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-reactive-scope.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-utils.js","meteor://ðŸ’»app/packages/angular/modules/angular-meteor-camera.js","meteor://ðŸ’»app/packages/angular/angular-meteor.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oH;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oH;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oH;;;;;;;;;;;;;;;;;;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oH;;;;;;;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mH","file":"/packages/angular.js","sourcesContent":["'use strict';\n\nvar module = angular.module('diffArray', ['getUpdates']);\n\nmodule.factory('diffArray', ['getUpdates',\n  function(getUpdates) {\n    var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n    var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\n    // Calculates the differences between `lastSeqArray` and\n    // `seqArray` and calls appropriate functions from `callbacks`.\n    // Reuses Minimongo's diff algorithm implementation.\n    // XXX Should be replaced with the original diffArray function here:\n    // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n    // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n    function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n      preventNestedDiff = !!preventNestedDiff;\n\n      var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges ||\n        Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\n      var oldObjIds = [];\n      var newObjIds = [];\n      var posOld = {}; // maps from idStringify'd ids\n      var posNew = {}; // ditto\n      var posCur = {};\n      var lengthCur = lastSeqArray.length;\n\n      _.each(seqArray, function (doc, i) {\n        newObjIds.push({_id: doc._id});\n        posNew[idStringify(doc._id)] = i;\n      });\n\n      _.each(lastSeqArray, function (doc, i) {\n        oldObjIds.push({_id: doc._id});\n        posOld[idStringify(doc._id)] = i;\n        posCur[idStringify(doc._id)] = i;\n      });\n\n      // Arrays can contain arbitrary objects. We don't diff the\n      // objects. Instead we always fire 'changedAt' callback on every\n      // object. The consumer of `observe-sequence` should deal with\n      // it appropriately.\n      diffFn(oldObjIds, newObjIds, {\n        addedBefore: function (id, doc, before) {\n          var position = before ? posCur[idStringify(before)] : lengthCur;\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= position) posCur[id]++;\n          });\n\n          lengthCur++;\n          posCur[idStringify(id)] = position;\n\n          callbacks.addedAt(\n            id,\n            seqArray[posNew[idStringify(id)]],\n            position,\n            before\n          );\n        },\n\n        movedBefore: function (id, before) {\n          var prevPosition = posCur[idStringify(id)];\n          var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition && pos <= position)\n              posCur[id]--;\n            else if (pos <= prevPosition && pos >= position)\n              posCur[id]++;\n          });\n\n          posCur[idStringify(id)] = position;\n\n          callbacks.movedTo(\n            id,\n            seqArray[posNew[idStringify(id)]],\n            prevPosition,\n            position,\n            before\n          );\n        },\n        removed: function (id) {\n          var prevPosition = posCur[idStringify(id)];\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition) posCur[id]--;\n          });\n\n          delete posCur[idStringify(id)];\n          lengthCur--;\n\n          callbacks.removedAt(\n            id,\n            lastSeqArray[posOld[idStringify(id)]],\n            prevPosition\n          );\n        }\n      });\n\n      _.each(posNew, function (pos, idString) {\n        if (!_.has(posOld, idString)) return;\n\n        var id = idParse(idString);\n        var newItem = seqArray[pos] || {};\n        var oldItem = lastSeqArray[posOld[idString]];\n        var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n        var setDiff = updates.$set;\n        var unsetDiff = updates.$unset;\n\n        if (setDiff)\n          setDiff._id = newItem._id;\n\n        if (unsetDiff)\n          unsetDiff._id = newItem._id;\n\n        if (setDiff || unsetDiff)\n          callbacks.changedAt(id, setDiff, unsetDiff, pos, oldItem);\n      });\n    }\n\n    diffArray.deepCopyChanges = function (oldItem, newItem) {\n      var setDiff = getUpdates(oldItem, newItem).$set;\n\n      _.each(setDiff, function(v, deepKey) {\n        setDeep(oldItem, deepKey, v);\n      });\n    };\n\n    diffArray.deepCopyRemovals = function (oldItem, newItem) {\n      var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\n      _.each(unsetDiff, function(v, deepKey) {\n        unsetDeep(oldItem, deepKey);\n      });\n    };\n\n    var setDeep = function(obj, deepKey, v) {\n      var split = deepKey.split('.');\n      var initialKeys = _.initial(split);\n      var lastKey = _.last(split);\n\n      initialKeys.reduce(function(subObj, k, i) {\n        var nextKey = split[i + 1];\n\n        if (isNumStr(nextKey)) {\n          if (subObj[k] == null) subObj[k] = [];\n          if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n        }\n\n        else if (subObj[k] == null || !isHash(subObj[k])) {\n          subObj[k] = {};\n        }\n\n        return subObj[k];\n      }, obj);\n\n      getDeep(obj, initialKeys)[lastKey] = v;\n      return v;\n    };\n\n    var unsetDeep = function(obj, deepKey) {\n      var split = deepKey.split('.');\n      var initialKeys = _.initial(split);\n      var lastKey = _.last(split);\n      return delete getDeep(obj, initialKeys)[lastKey];\n    };\n\n    var getDeep = function(obj, keys) {\n      return keys.reduce(function(subObj, k) {\n        return subObj[k];\n      }, obj);\n    };\n\n    var isHash = function(obj) {\n      return _.isObject(obj) &&\n             Object.getPrototypeOf(obj) === Object.prototype;\n    };\n\n    var isNumStr = function(str) {\n      return str.match(/^\\d+$/);\n    };\n\n    return diffArray;\n}]);\n","'use strict';\n\n// https://github.com/DAB0mB/get-updates\n(function() {\n  var module = angular.module('getUpdates', []);\n\n  var utils = (function() {\n    var rip = function(obj, level) {\n      if (level < 1) return {};\n\n      return _.reduce(obj, function(clone, v, k) {\n        v = _.isObject(v) ? rip(v, --level) : v;\n        clone[k] = v;\n        return clone;\n      }, {});\n    };\n\n    var toPaths = function(obj) {\n      var keys = getKeyPaths(obj);\n      var values = getDeepValues(obj);\n      return _.object(keys, values);\n    };\n\n    var getKeyPaths = function(obj) {\n      var keys = _.keys(obj).map(function(k) {\n        var v = obj[k];\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\n\n        return getKeyPaths(v).map(function(subKey) {\n          return k + '.' + subKey;\n        });\n      });\n\n      return _.flatten(keys);\n    };\n\n    var getDeepValues = function(obj,arr) {\n      arr = arr || [];\n\n      _.values(obj).forEach(function(v) {\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v))\n          arr.push(v);\n        else\n          getDeepValues(v, arr);\n      });\n\n      return arr;\n    };\n\n    var flatten = function(arr) {\n      return arr.reduce(function(flattened, v, i) {\n        if (_.isArray(v) && !_.isEmpty(v))\n          flattened.push.apply(flattened, flatten(v));\n        else\n          flattened.push(v);\n\n        return flattened;\n      }, []);\n    };\n\n    var setFilled = function(obj, k, v) {\n      if (!_.isEmpty(v)) obj[k] = v;\n    };\n\n    var assert = function(result, msg) {\n      if (!result) throwErr(msg);\n    };\n\n    var throwErr = function(msg) {\n      throw Error('get-updates error - ' + msg);\n    };\n\n    return {\n      rip: rip,\n      toPaths: toPaths,\n      getKeyPaths: getKeyPaths,\n      getDeepValues: getDeepValues,\n      setFilled: setFilled,\n      assert: assert,\n      throwErr: throwErr\n    };\n  })();\n\n  var getDifference = (function() {\n    var getDifference = function(src, dst, isShallow) {\n      var level;\n\n      if (isShallow > 1)\n        level = isShallow;\n      else if (isShallow)\n        level = 1;\n\n      if (level) {\n        src = utils.rip(src, level);\n        dst = utils.rip(dst, level);\n      }\n\n      return compare(src, dst);\n    };\n\n    var compare = function(src, dst) {\n      var srcKeys = _.keys(src);\n      var dstKeys = _.keys(dst);\n\n      var keys = _.chain([])\n        .concat(srcKeys)\n        .concat(dstKeys)\n        .uniq()\n        .without('$$hashKey')\n        .value();\n\n      return keys.reduce(function(diff, k) {\n        var srcValue = src[k];\n        var dstValue = dst[k];\n\n        if (_.isDate(srcValue) && _.isDate(dstValue)) {\n          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n        }\n\n        if (_.isObject(srcValue) && _.isObject(dstValue)) {\n          var valueDiff = getDifference(srcValue, dstValue);\n          utils.setFilled(diff, k, valueDiff);\n        }\n\n        else if (srcValue !== dstValue) {\n          diff[k] = dstValue;\n        }\n\n        return diff;\n      }, {});\n    };\n\n    return getDifference;\n  })();\n\n  var getUpdates = (function() {\n    var getUpdates = function(src, dst, isShallow) {\n      utils.assert(_.isObject(src), 'first argument must be an object');\n      utils.assert(_.isObject(dst), 'second argument must be an object');\n\n      var diff = getDifference(src, dst, isShallow);\n      var paths = utils.toPaths(diff);\n\n      var set = createSet(paths);\n      var unset = createUnset(paths);\n      var pull = createPull(unset);\n\n      var updates = {};\n      utils.setFilled(updates, '$set', set);\n      utils.setFilled(updates, '$unset', unset);\n      utils.setFilled(updates, '$pull', pull);\n\n      return updates;\n    };\n\n    var createSet = function(paths) {\n      var undefinedKeys = getUndefinedKeys(paths);\n      return _.omit(paths, undefinedKeys);\n    };\n\n    var createUnset = function(paths) {\n      var undefinedKeys = getUndefinedKeys(paths);\n      var unset = _.pick(paths, undefinedKeys);\n\n      return _.reduce(unset, function(result, v, k) {\n        result[k] = true;\n        return result;\n      }, {});\n    };\n\n    var createPull = function(unset) {\n      var arrKeyPaths = _.keys(unset).map(function(k) {\n        var split = k.match(/(.*)\\.\\d+$/);\n        return split && split[1];\n      });\n\n      return _.compact(arrKeyPaths).reduce(function(pull, k) {\n        pull[k] = null;\n        return pull;\n      }, {});\n    };\n\n    var getUndefinedKeys = function(obj) {\n      return _.keys(obj).filter(function (k) {\n        var v = obj[k];\n        return _.isUndefined(v);\n      });\n    };\n\n    return getUpdates;\n  })();\n\n  module.value('getUpdates', getUpdates);\n})();\n","'use strict';\nvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', []);\n\nangularMeteorSubscribe.service('$meteorSubscribe', ['$q',\n  function ($q) {\n    var self = this;\n\n    this._subscribe = function(scope, deferred, args) {\n      var subscription = null;\n      var lastArg = args[args.length - 1];\n\n      // User supplied onStop callback\n      // save it for later use and remove\n      // from subscription arguments\n      if (angular.isObject(lastArg) &&\n          angular.isFunction(lastArg.onStop)) {\n        var onStop = lastArg.onStop;\n\n        args.pop();\n      }\n\n      args.push({\n        onReady: function() {\n          deferred.resolve(subscription);\n        },\n        onStop: function(err) {\n          if (!deferred.promise.$$state.status) {\n            if (err)\n              deferred.reject(err);\n            else\n              deferred.reject(new Meteor.Error(\"Subscription Stopped\",\n                \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n          } else if (onStop)\n            // After promise was resolved or rejected\n            // call user supplied onStop callback.\n            onStop.apply(this, Array.prototype.slice.call(arguments));\n\n        }\n      });\n\n      subscription =  Meteor.subscribe.apply(scope, args);\n\n      return subscription;\n    };\n\n    this.subscribe = function(){\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n      var subscription = null;\n\n      self._subscribe(this, deferred, args);\n\n      return deferred.promise;\n    };\n  }]);\n\nangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe',\n  function($rootScope, $q, $meteorSubscribe) {\n    Object.getPrototypeOf($rootScope).$meteorSubscribe = function() {\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n\n      var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\n      this.$on('$destroy', function() {\n        subscription.stop();\n      });\n\n      return deferred.promise;\n    };\n}]);\n","'use strict';\n\nvar angularMeteorStopper = angular.module('angular-meteor.stopper',\n  ['angular-meteor.subscribe']);\n\nangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe',\n  function($q, $meteorSubscribe) {\n    function $meteorStopper($meteorEntity) {\n      return function() {\n        var args = Array.prototype.slice.call(arguments);\n        var meteorEntity = $meteorEntity.apply(this, args);\n\n        angular.extend(meteorEntity, $meteorStopper);\n        meteorEntity.$$scope = this;\n\n        this.$on('$destroy', function () {\n          meteorEntity.stop();\n          if (meteorEntity.subscription) meteorEntity.subscription.stop();\n        });\n\n        return meteorEntity;\n      };\n    }\n\n    $meteorStopper.subscribe = function() {\n      var args = Array.prototype.slice.call(arguments);\n      this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n      return this;\n    };\n\n    return $meteorStopper;\n}]);","'use strict';\n\nvar angularMeteorCollection = angular.module('angular-meteor.collection',\n  ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray']);\n\n// The reason angular meteor collection is a factory function and not something\n// that inherit from array comes from here:\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n// We went with the direct extensions approach.\nangularMeteorCollection.factory('AngularMeteorCollection', [\n  '$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray',\n  function($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray) {\n    function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n      var data = [];\n      // Server backup data to evaluate what changes come from client\n      // after each server update.\n      data._serverBackup = [];\n      // Array differ function.\n      data._diffArrayFunc = diffArrayFunc;\n      // Handler of the cursor observer.\n      data._hObserve = null;\n      // On new cursor autorun handler\n      // (autorun for reactive variables).\n      data._hNewCurAutorun = null;\n      // On new data autorun handler\n      // (autorun for cursor.fetch).\n      data._hDataAutorun = null;\n\n      if (angular.isDefined(collection)) {\n        data.$$collection = collection;\n      } else {\n        var cursor = curDefFunc();\n        data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n      }\n\n      angular.extend(data, AngularMeteorCollection);\n      data._startCurAutorun(curDefFunc, autoClientSave);\n\n      return data;\n    }\n\n    AngularMeteorCollection._startCurAutorun = function(curDefFunc, autoClientSave) {\n      var self = this;\n      self._hNewCurAutorun = Tracker.autorun(function() {\n        // When the reactive func gets recomputated we need to stop any previous\n        // observeChanges.\n        Tracker.onInvalidate(function() {\n          self._stopCursor();\n        });\n        if (autoClientSave) {\n          self._setAutoClientSave();\n        }\n        self._updateCursor(curDefFunc(), autoClientSave);\n      });\n    };\n\n    AngularMeteorCollection.subscribe = function() {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorCollection.save = function(docs, useUnsetModifier) {\n      // save whole collection\n      if (!docs) docs = this;\n      // save single doc\n      docs = [].concat(docs);\n\n      var promises = docs.map(function(doc) {\n        return this._upsertDoc(doc, useUnsetModifier);\n      }, this);\n\n      var allPromise = $q.all(promises);\n\n      allPromise.finally(function() {\n        // calls digestion loop with no conflicts\n        $timeout(angular.noop);\n      });\n\n      return allPromise;\n    };\n\n    AngularMeteorCollection._upsertDoc = function(doc, useUnsetModifier) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var upsertResult = function(action, _id) {\n        return {_id: _id, action: action }\n      }\n      var fulfill, createFulfill;\n\n      // delete $$hashkey\n      doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n      var docId = doc._id;\n      var isExist = collection.findOne(docId);\n\n      // update\n      if (isExist) {\n        // Deletes _id property (from the copy) so that\n        // it can be $set using update.\n        delete doc._id;\n        var modifier = useUnsetModifier ? {$unset: doc} : {$set: doc};\n        createFulfill = _.partial(upsertResult, 'updated');\n        fulfill = $meteorUtils.fulfill(deferred, null, createFulfill);\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\n        collection.update(docId, modifier, fulfill);\n      // insert\n      } else {\n        createFulfill = _.partial(upsertResult, 'inserted');\n        fulfill = $meteorUtils.fulfill(deferred, null, createFulfill);\n        collection.insert(doc, fulfill);\n      }\n\n      return deferred.promise;\n    };\n\n    AngularMeteorCollection.remove = function(keyOrDocs) {\n      var keys;\n      // remove whole collection\n      if (!keyOrDocs) {\n        keys = _.pluck(this, '_id');\n      } else {\n        // remove docs\n        keys = _.map([].concat(keyOrDocs), function(keyOrDoc) {\n          return keyOrDoc._id || keyOrDoc;\n        });\n      }\n      // Checks if all keys are correct.\n      check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\n      var promises = keys.map(function(key) {\n        return this._removeDoc(key);\n      }, this);\n\n      var allPromise = $q.all(promises);\n\n      allPromise.finally(function() {\n        $timeout(angular.noop);\n      });\n\n      return allPromise;\n    };\n\n    AngularMeteorCollection._removeDoc = function(id) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n      collection.remove(id, fulfill);\n      return deferred.promise;\n    };\n\n    AngularMeteorCollection._updateCursor = function(cursor, autoClientSave) {\n      var self = this;\n\n      // XXX - consider adding an option for a non-orderd result\n      // for faster performance.\n      if (self._hObserve) {\n        self._hObserve.stop();\n        self._hDataAutorun.stop();\n      }\n\n      var serverMode = false;\n      function setServerUpdateMode(name) {\n        serverMode = true;\n        // To simplify server update logic, we don't follow\n        // updates from the client at the same time.\n        self._unsetAutoClientSave();\n      }\n\n      var hUnsetTimeout = null;\n      // Here we use $timeout to combine multiple updates that go\n      // each one after another.\n      function unsetServerUpdateMode() {\n        if (hUnsetTimeout) {\n          $timeout.cancel(hUnsetTimeout);\n          hUnsetTimeout = null;\n        }\n        hUnsetTimeout = $timeout(function() {\n          serverMode = false;\n          // Finds updates that was potentially done from the client side\n          // and saves them.\n          var changes = collectionUtils.diff(self, self._serverBackup,\n            self._diffArrayFunc);\n          self._saveChanges(changes);\n          // After, continues following client updates.\n          if (autoClientSave) {\n            self._setAutoClientSave();\n          }\n        }, 0);\n      }\n\n      this._hObserve = cursor.observe({\n        addedAt: function(doc, atIndex) {\n          self.splice(atIndex, 0, doc);\n          self._serverBackup.splice(atIndex, 0, doc);\n          setServerUpdateMode();\n        },\n\n        changedAt: function(doc, oldDoc, atIndex) {\n          diffArray.deepCopyChanges(self[atIndex], doc);\n          diffArray.deepCopyRemovals(self[atIndex], doc);\n          self._serverBackup[atIndex] = self[atIndex];\n          setServerUpdateMode();\n        },\n\n        movedTo: function(doc, fromIndex, toIndex) {\n          self.splice(fromIndex, 1);\n          self.splice(toIndex, 0, doc);\n          self._serverBackup.splice(fromIndex, 1);\n          self._serverBackup.splice(toIndex, 0, doc);\n          setServerUpdateMode();\n        },\n\n        removedAt: function(oldDoc) {\n          var removedIndex = collectionUtils.findIndexById(self, oldDoc);\n\n          if (removedIndex != -1) {\n            self.splice(removedIndex, 1);\n            self._serverBackup.splice(removedIndex, 1);\n            setServerUpdateMode();\n          } else {\n            // If it's been removed on client then it's already not in collection\n            // itself but still is in the _serverBackup.\n            removedIndex = collectionUtils.findIndexById(self._serverBackup, oldDoc);\n\n            if (removedIndex != -1) {\n              self._serverBackup.splice(removedIndex, 1);\n            }\n          }\n        }\n      });\n\n      this._hDataAutorun = Tracker.autorun(function() {\n        cursor.fetch();\n        if (serverMode) {\n          unsetServerUpdateMode();\n        }\n      });\n    };\n\n    AngularMeteorCollection.stop = function() {\n      this._stopCursor();\n      this._hNewCurAutorun.stop();\n    };\n\n    AngularMeteorCollection._stopCursor = function() {\n      this._unsetAutoClientSave();\n\n      if (this._hObserve) {\n        this._hObserve.stop();\n        this._hDataAutorun.stop();\n      }\n\n      this.splice(0);\n      this._serverBackup.splice(0);\n    };\n\n    AngularMeteorCollection._unsetAutoClientSave = function(name) {\n      if (this._hRegAutoBind) {\n        this._hRegAutoBind();\n        this._hRegAutoBind = null;\n      }\n    };\n\n    AngularMeteorCollection._setAutoClientSave = function() {\n      var self = this;\n\n      // Always unsets auto save to keep only one $watch handler.\n      self._unsetAutoClientSave();\n\n      self._hRegAutoBind = $rootScope.$watch(function() {\n        return self;\n      }, function(nItems, oItems) {\n        if (nItems === oItems) return;\n\n        self._unsetAutoClientSave();\n        var changes = collectionUtils.diff(self, oItems,\n          self._diffArrayFunc);\n        self._saveChanges(changes);\n        self._setAutoClientSave();\n      }, true);\n    };\n\n    AngularMeteorCollection._saveChanges = function(changes) {\n      // First applies changes to the collection itself.\n      var newDocs = [];\n      for (var itemInd = changes.added.length - 1; itemInd >= 0; itemInd--) {\n        this.splice(changes.added[itemInd].index, 1);\n        newDocs.push(changes.added[itemInd].item);\n      }\n      // Then saves all new docs in bulk.\n      if (newDocs.length) {\n        this.save(newDocs);\n      }\n\n      // Collects docs to remove.\n      var removeDocs = [];\n      for (var itemInd = 0; itemInd < changes.removed.length; itemInd++) {\n        removeDocs.push(changes.removed[itemInd].item);\n      }\n      // Removes docs in bulk.\n      if (removeDocs.length) {\n        this.remove(removeDocs);\n      }\n\n      // Collects set and unset changes.\n      var setDocs = [], unsetDocs = [];\n      for (var itemInd = 0; itemInd < changes.changed.length; itemInd++) {\n        var change = changes.changed[itemInd];\n        if (change.setDiff) {\n          setDocs.push(change.setDiff);\n        }\n        if (change.unsetDiff) {\n          unsetDocs.push(change.unsetDiff);\n        }\n      }\n      // Then saves all changes in bulk.\n      if (setDocs.length) {\n        this.save(setDocs);\n      }\n      if (unsetDocs.length) {\n        this.save(unsetDocs, true);\n      }\n    };\n\n    return AngularMeteorCollection;\n}]);\n\nangularMeteorCollection.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray',\n  function($meteorCollection, diffArray) {\n    function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n      return new $meteorCollection(reactiveFunc, autoClientSave, collection, noNestedDiffArray);\n    }\n\n    var noNestedDiffArray = function(lastSeqArray, seqArray, callbacks) {\n      return diffArray(lastSeqArray, seqArray, callbacks, true);\n    };\n\n    return $meteorCollectionFS;\n}]);\n\nangularMeteorCollection.factory('$meteorCollection', [\n  'AngularMeteorCollection', '$rootScope', 'diffArray',\n  function(AngularMeteorCollection, $rootScope, diffArray) {\n    function $meteorCollection(reactiveFunc, autoClientSave, collection, diffArrayFunc) {\n      // Validate parameters\n      if (!reactiveFunc) {\n        throw new TypeError('The first argument of $meteorCollection is undefined.');\n      }\n\n      if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n        throw new TypeError(\n          'The first argument of $meteorCollection must be a function or\\\n            a have a find function property.');\n      }\n\n      if (!angular.isFunction(reactiveFunc)) {\n        collection = angular.isDefined(collection) ? collection : reactiveFunc;\n        reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\n      }\n\n      // By default auto save - true.\n      autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n      var ngCollection = new AngularMeteorCollection(reactiveFunc, collection,\n        diffArrayFunc || diffArray, autoClientSave);\n\n      return ngCollection;\n    }\n\n    return $meteorCollection;\n }]);\n\nangularMeteorCollection.run([\n  '$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper',\n  function($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n    var scopeProto = Object.getPrototypeOf($rootScope);\n    scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n    scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n }]);\n\n\n// Local utilities\nvar collectionUtils = {\n\n  findIndexById: function(collection, doc) {\n    var foundDoc = _.find(collection, function(colDoc) {\n      // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n      return EJSON.equals(colDoc._id, doc._id);\n    });\n    return _.indexOf(collection, foundDoc);\n  },\n\n  // Finds changes between two collections and saves differences.\n  diff: function(newCollection, oldCollection, diffMethod) {\n    var changes = {added: [], removed: [], changed: []};\n\n    diffMethod(oldCollection, newCollection, {\n      addedAt: function(id, item, index) {\n        changes.added.push({item: item, index: index});\n      },\n\n      removedAt: function(id, item, index) {\n        changes.removed.push({item: item, index: index});\n      },\n\n      changedAt: function(id, setDiff, unsetDiff, index, oldItem) {\n        changes.changed.push({setDiff: setDiff, unsetDiff: unsetDiff});\n      },\n\n      movedTo: function(id, item, fromIndex, toIndex) {\n        // XXX do we need this?\n      }\n    });\n\n    return changes;\n  }\n};\n","'use strict';\n\nvar angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray']);\n\nangularMeteorObject.factory('AngularMeteorObject', [\n  '$q', '$meteorSubscribe', '$meteorCollection', '$meteorUtils', 'diffArray', 'getUpdates',\n  function($q, $meteorSubscribe, $meteorCollection, $meteorUtils, diffArray, getUpdates) {\n    // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n    AngularMeteorObject.$$internalProps = [\n      '$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope',\n      'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject',\n      '_auto', '_setAutos', '_eventEmitter', '_serverBackup'\n    ];\n\n    function AngularMeteorObject (collection, id, options){\n      // Make data not be an object so we can extend it to preserve\n      // Collection Helpers and the like\n      var data = new function SubObject() {};\n      var doc = collection.findOne(id, options);\n      angular.extend(data, doc);\n      angular.extend(data, AngularMeteorObject);\n\n      data._serverBackup = doc || {};\n      data.$$collection = collection;\n      data.$$options = options;\n      data.$$id = id || new Mongo.ObjectID();\n\n      return data;\n    }\n\n    AngularMeteorObject.getRawObject = function () {\n      return angular.copy(_.omit(this, this.$$internalProps));\n    };\n\n    AngularMeteorObject.subscribe = function () {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorObject.save = function(custom) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n      var oldDoc = collection.findOne(this.$$id);\n      var mods;\n\n      // update\n      if (oldDoc) {\n        if (custom)\n          mods = { $set: custom };\n        else {\n          mods = getUpdates(oldDoc, this.getRawObject());\n          // If there are no updates, there is nothing to do here, returning\n          if (_.isEmpty(mods)) {\n            return $q.when({ action: 'updated' });\n          }\n        }\n\n        var pullUpdate;\n        if (mods.$pull) {\n          pullUpdate = { $pull : mods.$pull };\n        }\n\n        if (!pullUpdate) {\n          // NOTE: do not use #upsert() method, since it does not exist in some collections\n          collection.update(this.$$id, mods, createFulfill({action: 'updated'}));\n        }\n        else {\n          collection.update(this.$$id, mods);\n          collection.update(this.$$id, pullUpdate, createFulfill({action: 'updated'}))\n        }\n      }\n      // insert\n      else {\n        if (custom)\n          mods = _.clone(custom);\n        else\n          mods = this.getRawObject();\n\n        mods._id = this.$$id;\n        collection.insert(mods, createFulfill({ action: 'inserted' }));\n      }\n\n      return deferred.promise;\n    };\n\n    AngularMeteorObject.reset = function(keepClientProps) {\n      var self = this;\n      var options = this.$$options;\n      var id = this.$$id;\n      var doc = this.$$collection.findOne(id, options);\n\n      if (doc) {\n        // extend SubObject\n        var docKeys = _.keys(doc);\n        var docExtension = _.pick(doc, docKeys);\n        var clientProps;\n\n        angular.extend(Object.getPrototypeOf(self), Object.getPrototypeOf(doc));\n        _.extend(self, docExtension);\n        _.extend(self._serverBackup, docExtension);\n\n        if (keepClientProps) {\n          clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\n        } else {\n          clientProps = _.keys(self);\n        }\n\n        var serverProps = _.keys(doc);\n        var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\n\n        removedKeys.forEach(function (prop) {\n          delete self[prop];\n          delete self._serverBackup[prop];\n        });\n      }\n\n      else {\n        _.keys(this.getRawObject()).forEach(function(prop) {\n          delete self[prop];\n        });\n\n        self._serverBackup = {};\n      }\n    };\n\n    AngularMeteorObject.stop = function () {\n      if (this.unregisterAutoDestroy)\n        this.unregisterAutoDestroy();\n\n      if (this.unregisterAutoBind)\n        this.unregisterAutoBind();\n\n      if (this.autorunComputation && this.autorunComputation.stop)\n        this.autorunComputation.stop();\n    };\n\n    return AngularMeteorObject;\n}]);\n\n\nangularMeteorObject.factory('$meteorObject', [\n  '$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject',\n  function($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n    function $meteorObject(collection, id, auto, options) {\n      // Validate parameters\n      if (!collection) {\n        throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n      }\n\n      if (!angular.isFunction(collection.findOne)) {\n        throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n      }\n\n      var data = new AngularMeteorObject(collection, id, options);\n      data._auto = auto !== false; // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n      angular.extend(data, $meteorObject);\n      data._setAutos();\n      return data;\n    }\n\n    $meteorObject._setAutos = function() {\n      var self = this;\n\n      this.autorunComputation = $meteorUtils.autorun($rootScope, function() {\n        self.reset(true);\n      });\n\n      // Deep watches the model and performs autobind\n      this.unregisterAutoBind = this._auto && $rootScope.$watch(function(){\n        return self.getRawObject();\n      }, function (item, oldItem) {\n        if (item === oldItem) {\n          self.$$collection.update({_id: item._id}, self.getRawObject());\n          return;\n        }\n\n        var id = item._id;\n        delete item._id;\n        delete oldItem._id;\n\n        var updates = getUpdates(oldItem, item);\n        if (_.isEmpty(updates)) return;\n        var pullUpdate;\n\n        if (updates.$pull) {\n          pullUpdate = { $pull : updates.$pull };\n          delete updates.$pull;\n        }\n        self.$$collection.update({_id: id}, updates);\n\n        if (pullUpdate) {\n          self.$$collection.update({ _id : id}, pullUpdate);\n        }\n      }, true);\n\n      this.unregisterAutoDestroy = $rootScope.$on('$destroy', function() {\n        if (self && self.stop) {\n          self.stop();\n        }\n      });\n    };\n\n    return $meteorObject;\n}]);\n\nangularMeteorObject.run([\n  '$rootScope', '$meteorObject', '$meteorStopper',\n  function ($rootScope, $meteorObject, $meteorStopper) {\n    var scopeProto = Object.getPrototypeOf($rootScope);\n    scopeProto.$meteorObject = $meteorStopper($meteorObject);\n}]);\n","'use strict';\n\nvar angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils']);\n\n// requires package 'accounts-password'\nangularMeteorUser.service('$meteorUser', [\n  '$rootScope', '$meteorUtils', '$q',\n  function($rootScope, $meteorUtils, $q){\n    var pack = Package['accounts-base'];\n    if (!pack) return;\n\n    var self = this;\n    var Accounts = pack.Accounts;\n\n    this.waitForUser = function(){\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() )\n          deferred.resolve( Meteor.user() );\n      });\n\n      return deferred.promise;\n    };\n\n    this.requireUser = function(){\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() ) {\n          if ( Meteor.user() == null)\n            deferred.reject(\"AUTH_REQUIRED\");\n          else\n            deferred.resolve( Meteor.user() );\n        }\n      });\n\n      return deferred.promise;\n    };\n\n    this.requireValidUser = function(validatorFn) {\n      return self.requireUser().then(function(user){\n        var valid = validatorFn( user );\n\n        if ( valid === true )\n          return user;\n        else if ( typeof valid === \"string\" )\n          return $q.reject( valid );\n        else\n          return $q.reject( \"FORBIDDEN\" );\n\t    });\n\t  };\n\n    this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n    this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n    this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n    this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n    this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n    this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n    this.logout = $meteorUtils.promissor(Meteor, 'logout');\n    this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n    this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n    this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n    this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n    this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n    this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n    this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n    this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n  }\n]);\n\nangularMeteorUser.run([\n  '$rootScope', '$meteorUtils',\n  function($rootScope, $meteorUtils){\n    $meteorUtils.autorun($rootScope, function(){\n      if (!Meteor.user) return;\n      $rootScope.currentUser = Meteor.user();\n      $rootScope.loggingIn = Meteor.loggingIn();\n    });\n  }\n]);","'use strict';\n\nvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils']);\n\nangularMeteorMethods.service('$meteorMethods', [\n  '$q', '$meteorUtils',\n  function($q, $meteorUtils) {\n    this.call = function(){\n      var deferred = $q.defer();\n      var fulfill = $meteorUtils.fulfill(deferred);\n      var args = _.toArray(arguments).concat(fulfill);\n      Meteor.call.apply(this, args);\n      return deferred.promise;\n    };\n  }\n]);","'use strict';\nvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils']);\n\nangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse',\n  function ($meteorUtils, $parse) {\n    return function (session) {\n\n      return {\n\n        bind: function(scope, model) {\n          var getter = $parse(model);\n          var setter = getter.assign;\n          $meteorUtils.autorun(scope, function() {\n            setter(scope, Session.get(session));\n          });\n\n          scope.$watch(model, function(newItem, oldItem) {\n            Session.set(session, getter(scope));\n          }, true);\n\n        }\n      };\n    }\n  }\n]);\n\n","/**\n * Created by netanel on 29/12/14.\n */\nvar angularMeteorReactiveScope = angular.module('angular-meteor.reactive-scope', []);\n\nangularMeteorReactiveScope.run(['$rootScope', '$parse', function($rootScope, $parse) {\n  Object.getPrototypeOf($rootScope).getReactively = function(property, objectEquality) {\n    var self = this;\n    var getValue = $parse(property);\n    objectEquality = !!objectEquality;\n\n    if (!self.hasOwnProperty('$$trackerDeps')) {\n      self.$$trackerDeps = {};\n    }\n\n    if (!self.$$trackerDeps[property]) {\n      self.$$trackerDeps[property] = new Tracker.Dependency();\n\n      self.$watch(function() {\n        return getValue(self)\n      }, function(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          self.$$trackerDeps[property].changed();\n        }\n      }, objectEquality);\n    }\n\n    self.$$trackerDeps[property].depend();\n\n    return getValue(self);\n  };\n  Object.getPrototypeOf($rootScope).getCollectionReactively = function(property) {\n    var self = this;\n    var getValue = $parse(property);\n\n\n    if (!self.hasOwnProperty('$$trackerDeps')) {\n      self.$$trackerDeps = {};\n    }\n\n    if (!self.$$trackerDeps[property]) {\n      self.$$trackerDeps[property] = new Tracker.Dependency();\n\n      self.$watchCollection(property, function() {\n        self.$$trackerDeps[property].changed();\n      });\n    }\n\n    self.$$trackerDeps[property].depend();\n\n    return getValue(self);\n  };\n}]);\n","'use strict';\nvar angularMeteorUtils = angular.module('angular-meteor.utils', []);\n\nangularMeteorUtils.service('$meteorUtils', [\n  '$q', '$timeout',\n  function ($q, $timeout) {\n    var self = this;\n    this.getCollectionByName = function(string){\n      return Mongo.Collection.get(string);\n    };\n    this.autorun = function(scope, fn) {\n      // wrapping around Deps.autorun\n      var comp = Tracker.autorun(function(c) {\n        fn(c);\n\n        // this is run immediately for the first call\n        // but after that, we need to $apply to start Angular digest\n        if (!c.firstRun) $timeout(angular.noop, 0);\n      });\n      // stop autorun when scope is destroyed\n      scope.$on('$destroy', function() {\n        comp.stop();\n      });\n      // return autorun object so that it can be stopped manually\n      return comp;\n    };\n    // Borrowed from angularFire - https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n    this.stripDollarPrefixedKeys = function (data) {\n      if( !angular.isObject(data) ||\n        data instanceof Date ||\n        data instanceof File ||\n        (typeof FS === 'object' && data instanceof FS.File)) {\n        return data;\n      }\n      var out = angular.isArray(data)? [] : {};\n      angular.forEach(data, function(v,k) {\n        if(typeof k !== 'string' || k.charAt(0) !== '$') {\n          out[k] = self.stripDollarPrefixedKeys(v);\n        }\n      });\n      return out;\n    };\n    // Returns a callback which fulfills promise\n    this.fulfill = function(deferred, boundError, boundResult) {\n      return function(err, result) {\n        if (err)\n          deferred.reject(boundError == null ? err : boundError);\n        else if (typeof boundResult == \"function\")\n          deferred.resolve(boundResult == null ? result : boundResult(result));\n        else\n          deferred.resolve(boundResult == null ? result : boundResult);\n      };\n    };\n    // creates a function which invokes method with the given arguments and returns a promise\n    this.promissor = function(obj, method) {\n      return function() {\n        var deferred = $q.defer();\n        var fulfill = self.fulfill(deferred);\n        var args = _.toArray(arguments).concat(fulfill);\n        obj[method].apply(obj, args);\n        return deferred.promise;\n      };\n    };\n  }\n]);\n\nangularMeteorUtils.run(['$rootScope', '$meteorUtils',\n  function($rootScope, $meteorUtils) {\n    Object.getPrototypeOf($rootScope).$meteorAutorun = function(fn) {\n      return $meteorUtils.autorun(this, fn);\n    };\n}]);\n","'use strict';\n\nvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils']);\n\n// requires package 'mdg:camera'\nangularMeteorCamera.service('$meteorCamera', [\n  '$q', '$meteorUtils',\n  function ($q, $meteorUtils) {\n    var pack = Package['mdg:camera'];\n    if (!pack) return;\n\n    var MeteorCamera = pack.MeteorCamera;\n\n    this.getPicture = function(options){\n      options = options || {};\n      var deferred = $q.defer();\n      MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n      return deferred.promise;\n    };\n  }\n]);\n","// Define angular-meteor and its dependencies\nvar angularMeteor = angular.module('angular-meteor', [\n  'angular-meteor.subscribe',\n  'angular-meteor.collection',\n  'angular-meteor.object',\n  'angular-meteor.user',\n  'angular-meteor.methods',\n  'angular-meteor.session',\n  'angular-meteor.reactive-scope',\n  'angular-meteor.utils',\n  'angular-meteor.camera'\n]);\n\nangularMeteor.run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n    // Recompile after iron:router builds page\n    if(Package['iron:router']) {\n      var appLoaded = false;\n      Package['iron:router'].Router.onAfterAction(function(req, res, next) {\n        Tracker.afterFlush(function() {\n          if (!appLoaded) {\n            $compile($document)($rootScope);\n            if (!$rootScope.$$phase) $rootScope.$apply();\n            appLoaded = true;\n          }\n        })\n      });\n    }\n  }]);\n\n// Putting all services under $meteor service for syntactic sugar\nangularMeteor.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser',\n  function($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser){\n    this.collection = $meteorCollection;\n    this.collectionFS = $meteorCollectionFS;\n    this.object = $meteorObject;\n    this.subscribe = $meteorSubscribe.subscribe;\n    this.call = $meteorMethods.call;\n    this.loginWithPassword = $meteorUser.loginWithPassword;\n    this.requireUser = $meteorUser.requireUser;\n    this.requireValidUser = $meteorUser.requireValidUser;\n    this.waitForUser = $meteorUser.waitForUser;\n    this.createUser = $meteorUser.createUser;\n    this.changePassword = $meteorUser.changePassword;\n    this.forgotPassword = $meteorUser.forgotPassword;\n    this.resetPassword = $meteorUser.resetPassword;\n    this.verifyEmail = $meteorUser.verifyEmail;\n    this.loginWithMeteorDeveloperAccount = $meteorUser.loginWithMeteorDeveloperAccount;\n    this.loginWithFacebook = $meteorUser.loginWithFacebook;\n    this.loginWithGithub = $meteorUser.loginWithGithub;\n    this.loginWithGoogle = $meteorUser.loginWithGoogle;\n    this.loginWithMeetup = $meteorUser.loginWithMeetup;\n    this.loginWithTwitter = $meteorUser.loginWithTwitter;\n    this.loginWithWeibo = $meteorUser.loginWithWeibo;\n    this.logout = $meteorUser.logout;\n    this.logoutOtherClients = $meteorUser.logoutOtherClients;\n    this.session = $meteorSession;\n    this.autorun = $meteorUtils.autorun;\n    this.getCollectionByName = $meteorUtils.getCollectionByName;\n    this.getPicture = $meteorCamera.getPicture;\n}]);\n"]}