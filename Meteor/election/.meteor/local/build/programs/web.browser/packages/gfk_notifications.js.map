{"version":3,"sources":["meteor://ðŸ’»app/packages/gfk_notifications/globals.js","meteor://ðŸ’»app/packages/gfk_notifications/template.notifications.js","meteor://ðŸ’»app/packages/gfk_notifications/notifications.js","meteor://ðŸ’»app/packages/gfk_notifications/template.notification.js","meteor://ðŸ’»app/packages/gfk_notifications/notification.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;;;;;;;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H","file":"/packages/gfk_notifications.js","sourcesContent":["/* global Notifications:true */\n/*jshint strict: false */\n\n//The purpose of this file is to be the one file where globals are declared.  This let's all other files use strict.\n// More info: https://github.com/meteor/meteor/issues/2437\n\n\nNotifications = {};\n","\nTemplate.__checkName(\"notifications\");\nTemplate[\"notifications\"] = new Template(\"Template.notifications\", (function() {\n  var view = this;\n  return HTML.UL({\n    \"class\": \"notifications\"\n  }, \"\\n       \", Blaze.Each(function() {\n    return Spacebars.call(view.lookup(\"notifications\"));\n  }, function() {\n    return [ \"\\n           \", Spacebars.include(view.lookupTemplate(\"notification\")), \"\\n       \" ];\n  }), \"\\n    \");\n}));\n","/* global Notifications:true */\n\"use strict\";\n\nvar constructor = (function() {\n    /***\n     * Creates an instance of Notifications\n     * @constructor\n     */\n    function Notifications(settings) {\n        settings = settings || {};\n        _.defaults(settings, this.defaultSettings);\n\n        this._notificationsCollection = new Mongo.Collection(null);\n        this._notificationTimeout = undefined;\n        this.settings = settings;\n    }\n\n    /***\n     * Adds a notification\n     * @param {String} title of the notification\n     * @param {String} message of the notification\n     * @param {Object}  [options={}] Options object to use for notification\n     * @param {String}  [options.type=defaultOptions.type] the type of the notification\n     * @param {Boolean} [options.userCloseable=defaultOptions.userCloseable] Whether the notification is user closeable\n     * @param {Boolean} [options.clickBodyToClose=defaultOptions.clickBodyToClose] Whether the notification can be closed by clicking anywhere within its body. If turned off then the close button must clicked.\n     * @param {Function} [options.closed] Call this handler (passing data context) on notification close\n     * @param {Function} [options.timeout] No. of milliseconds to show this notification for.\n     */\n    Notifications.prototype.addNotification = function (title, message, options) {\n        options = options || {};\n        _.defaults(options, this.getDefaultOptions(options.type));\n\n        var notification = {};\n        notification.title = title;\n        notification.message = message;\n        notification.type = options.type;\n        notification.userCloseable = options.userCloseable;\n        notification.clickBodyToClose = options.clickBodyToClose;\n        notification.closed = options.closed;\n\n        if (options.timeout) {\n            notification.expires = new Date().getTime() + options.timeout;\n        }\n\n        return this._add(notification);\n    };\n\n    /***\n     * Wraps addNotification, sets type to error\n     * @param {String} title of the notification\n     * @param {String} message of the notification\n     * @param {Object}  [options={}] Options object to use for notification\n     * @param {Boolean} [options.userCloseable=defaultOptions.userCloseable] Whether the notification is user closeable\n     * @param {Function} [options.closed] Call this handler (passing data context) on notification close\n     * @returns {*}\n     */\n    Notifications.prototype.error = function (title, message, options) {\n        options = options || {};\n        options.type = this.TYPES.ERROR;\n        return this.addNotification(title, message, options);\n    };\n\n    /***\n     * Wraps addNotification, sets type to warning\n     * @param {String} title of the notification\n     * @param {String} message of the notification\n     * @param {Object}  [options={}] Options object to use for notification\n     * @param {Boolean} [options.userCloseable=defaultOptions.userCloseable] Whether the notification is user closeable\n     * @param {Function} [options.closed] Call this handler (passing data context) on notification close\n     * @returns {*}\n     */\n    Notifications.prototype.warn = function (title, message, options) {\n        options = options || {};\n        options.type = this.TYPES.WARNING;\n        return this.addNotification(title, message, options);\n    };\n\n    /***\n     * Wraps addNotification, sets type to info\n     * @param {String} title of the notification\n     * @param {String} message of the notification\n     * @param {Object}  [options={}] Options object to use for notification\n     * @param {Boolean} [options.userCloseable=defaultOptions.userCloseable] Whether the notification is user closeable\n     * @param {Function} [options.closed] Call this handler (passing data context) on notification close\n     * @returns {*}\n     */\n    Notifications.prototype.info = function (title, message, options) {\n        options = options || {};\n        options.type = this.TYPES.INFO;\n        return this.addNotification(title, message, options);\n    };\n\n    /***\n     * Wraps addNotification, sets type to success\n     * @param {String} title of the notification\n     * @param {String} message of the notification\n     * @param {Object}  [options={}] Options object to use for notification\n     * @param {Boolean} [options.userCloseable=defaultOptions.userCloseable] Whether the notification is user closeable\n     * @param {Function} [options.closed] Call this handler (passing data context) on notification close\n     * @returns {*}\n     */\n    Notifications.prototype.success = function (title, message, options) {\n        options = options || {};\n        options.type = this.TYPES.SUCCESS;\n        return this.addNotification(title, message, options);\n    };\n\n    /***\n     * Returns the NotificationsCollection Meteor.Collection\n     * @returns {object} NotificationsCollection\n     * @private\n     */\n    Notifications.prototype._getNotificationsCollection = function () {\n        return this._notificationsCollection;\n    };\n\n    /***\n     * Does the actual add to the collection. And creates a Timeout if necessary.\n     * @param {object} notification the object to be inserted into the collection\n     * @private\n     */\n    Notifications.prototype._add = function (notification) {\n        var notificationsCollection = this._getNotificationsCollection();\n        var firstExpiration = this._getFirstExpiredTimestamp();\n        var notificationID = notificationsCollection.insert(notification);\n\n        if (notification.expires) {\n            if (this._notificationTimeout) {\n                if (firstExpiration > notification.expires) {\n                    Meteor.clearTimeout(this._notificationTimeout);\n                    this._notificationTimeout = undefined;\n                }\n            }\n\n            if (!this._notificationTimeout) {\n                this._createTimeout();\n            }\n        }\n\n        return notificationID;\n    };\n\n    /***\n     * Returns the timestamp of the notification from the notificationsCollection that is first to expire\n     * @returns {string} first to expire timestamp\n     * @private\n     */\n    Notifications.prototype._getFirstExpiredTimestamp = function () {\n        var notificationsCollection = this._getNotificationsCollection();\n\n        var firstNotification = notificationsCollection.findOne({expires: {$gt: 0}}, {sort:[['expires', 'asc']]}, { reactive: false });\n        var firstExpiredTimestamp = firstNotification ? firstNotification.expires : 0;\n\n        return firstExpiredTimestamp;\n    };\n\n    /***\n     * creates a timeout for the first to expire notification.\n     * @private\n     */\n    Notifications.prototype._createTimeout = function () {\n        var self = this;\n        var firstExpiration = this._getFirstExpiredTimestamp();\n\n        if (firstExpiration) {\n            this._notificationTimeout = Meteor.setTimeout(function () {\n                self.remove({expires: {$lte: firstExpiration}});\n                self._createTimeout();\n            }, firstExpiration - new Date().getTime());\n        } else {\n            this._notificationTimeout = undefined;\n        }\n    };\n\n    /***\n     * gets the proper notification defaults based on type\n     * @param {String} notificationType the type of the notification for which to get the defaultOptions\n     */\n    Notifications.prototype.getDefaultOptions = function (notificationType) {\n        return this.defaultOptionsByType[notificationType] || this.defaultOptions;\n    };\n\n\n    /***\n     * Gets the class containing the color for the notification\n     * @param {String} notificationType\n     * @returns {string} classname to use for the notification\n     */\n    Notifications.prototype.getNotificationClass = function (notificationType) {\n        var notificationClass;\n\n        _.each(this.TYPES,  function (value, key) {\n            if(value === notificationType) {\n                notificationClass = key.toLowerCase();\n            }\n        });\n\n        return notificationClass;\n    };\n\n    /***\n     * Removes the notifications matching the selector\n     * @param selector\n     */\n    Notifications.prototype.remove = function (selector) {\n        this._getNotificationsCollection().remove(selector);\n\n        if (this._notificationTimeout) {\n            Meteor.clearTimeout(this._notificationTimeout);\n            this._notificationTimeout = undefined;\n            this._createTimeout();\n        }\n    };\n\n    /***\n     * Stores constants for the different notification types\n     * @type {{ERROR: number, WARNING: number, INFO: number, SUCCESS: number}}\n     */\n    Notifications.prototype.TYPES = {\n        'ERROR': 1,\n        'WARNING': 2,\n        'INFO': 3,\n        'SUCCESS': 4\n    };\n\n    /***\n     * Object with the default options for the notifications\n     * @type {{type: number, userCloseable: boolean, timeout: number, closed: function}}\n     */\n    Notifications.prototype.defaultOptions = {\n        type: Notifications.prototype.TYPES.INFO,\n        userCloseable: true,\n        clickBodyToClose: true,\n        timeout: 0\n    };\n\n    /***\n     * Object with the default options for the notifications for specific types\n     * @type {{type: number, userCloseable: boolean, timeout: number, closed: function}}\n     */\n    Notifications.prototype.defaultOptionsByType = {};\n\n\n    Notifications.prototype.defaultSettings = {\n        hideAnimationProperties: {\n            height: 0,\n            opacity: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            marginTop: 0\n        },\n        animationSpeed: 400\n    };\n\n    return Notifications;\n})();\n\nNotifications = new constructor();\n\nTemplate.notifications.helpers({\n    notifications: function() {\n        return Notifications._getNotificationsCollection().find();\n    }\n});\n\nTemplate.notifications.rendered = function () {\n    this.firstNode._uihooks = {\n        insertElement: function (node, next) {\n            var settings = Notifications.settings;\n            $(node)\n                .addClass('notificationHidden')\n                .insertBefore(next)\n                .fadeIn({duration: settings.animationSpeed})\n                .promise()\n                .done(function () {\n                    $(this).removeClass('notificationHidden');\n                });\n        },\n        removeElement: function (node) {\n            var settings = Notifications.settings;\n            $(node).animate(settings.hideAnimationProperties, {\n                duration: settings.animationSpeed,\n                complete: function () {\n                    $(node).remove();\n                }});\n        }\n    };\n};\n","\nTemplate.__checkName(\"notification\");\nTemplate[\"notification\"] = new Template(\"Template.notification\", (function() {\n  var view = this;\n  return HTML.LI({\n    \"class\": function() {\n      return [ \"notification \", Spacebars.mustache(view.lookup(\"notificationColor\"), view.lookup(\"type\")), \" \", Blaze.If(function() {\n        return Spacebars.call(view.lookup(\"userCloseable\"));\n      }, function() {\n        return \"closeable\";\n      }) ];\n    }\n  }, \"\\n         \", HTML.DIV({\n    \"class\": \"title\"\n  }, Blaze.View(\"lookup:title\", function() {\n    return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"title\")));\n  })), \"\\n         \", HTML.DIV({\n    \"class\": \"message\"\n  }, Blaze.View(\"lookup:message\", function() {\n    return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"message\")));\n  })), \"\\n         \", Blaze.If(function() {\n    return Spacebars.call(view.lookup(\"userCloseable\"));\n  }, function() {\n    return [ \"\\n                 \", HTML.DIV({\n      \"class\": \"closeButton\"\n    }, HTML.CharRef({\n      html: \"&times;\",\n      str: \"Ã—\"\n    })), \"\\n         \" ];\n  }), \"\\n     \");\n}));\n","'use strict';\n\nTemplate.notification.helpers({\n    notificationColor: function(notificationType) {\n        return Notifications.getNotificationClass(notificationType);\n    }\n});\n\nTemplate.notification.events = {\n    'click': function (event) {\n        if (this.userCloseable || this.expires < new Date()) {\n            // must the user click the close button?\n            if (!this.clickBodyToClose && 0 > event.target.className.indexOf('closeButton')) {\n                return;\n            }\n\n            Notifications.remove(this._id);\n            if (this.closed) {\n              this.closed(this);\n            }\n        }\n    }\n};\n"]}