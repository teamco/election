{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"/*!\n * angular-endless-scroll.js v0.0.5\n * http://davidchin.me\n * Copyright 2014 David Chin\n * MIT License\n */\n(function () {\n  'use strict';\n\n  /**\n   * @namespace dc\n   */\n\n  /**\n   * @module dc.endlessScroll\n   *\n   * @description\n   * A module for implementing an endless/infinite scroll user interface.\n   */\n  angular.module('dc.endlessScroll', []);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('dc.endlessScroll')\n\n  /**\n   * @member dc.endlessScroll.endlessScroll\n   *\n   * @description\n   * A directive for implementing an endless scrolling list.\n   */\n  .directive('endlessScroll', function ($window, $timeout) {\n    var NG_REPEAT_REGEXP = /^\\s*(.+)\\s+in\\s+([\\r\\n\\s\\S]*?)\\s*(\\s+track\\s+by\\s+(.+)\\s*)?$/;\n\n    /**\n     * @function throttle\n     * @private\n     * @param {Function} fn\n     * @param {number} delay\n     * @returns {Function}\n     *\n     * @description\n     * Return a function that only gets executed once within a given time period.\n     */\n    function throttle(fn, delay) {\n      var timeout,\n          previous = 0;\n\n      return function () {\n        var current = new Date().getTime(),\n            remaining = delay - (current - previous),\n            args = arguments;\n\n        if (remaining <= 0) {\n          if (timeout) {\n            $timeout.cancel(timeout);\n          }\n\n          timeout = undefined;\n          previous = current;\n\n          fn.apply(this, args);\n        } else if (!timeout) {\n          timeout = $timeout(function () {\n            timeout = undefined;\n            previous = new Date().getTime();\n\n            fn.apply(this, args);\n          }, remaining);\n        }\n      };\n    }\n\n    /**\n     * @function parseNgRepeatExp\n     * @private\n     * @param {string} expression\n     * @returns {Object}\n     *\n     * @description\n     * Parse ngRepeat expression and\n     * return the name of the loop variable, the collection and tracking expression\n     */\n    function parseNgRepeatExp(expression) {\n      var matches = expression.match(NG_REPEAT_REGEXP);\n\n      return {\n        item: matches[1],\n        collection: matches[2],\n        trackBy: matches[3]\n      };\n    }\n\n    /**\n     * @constructor dc.endlessScroll.EndlessScroller\n     * @param {Object} scope The scope of the directive.\n     * @param {Object} element The element of the directive.\n     * @param {Object} attrs The attributes of the directive.\n     *\n     * @description\n     * The controller of endlessScroll directive.\n     * Each directive creates an instance of EndlessScroller.\n     */\n    function EndlessScroller(scope, element, attrs) {\n      var defaultOptions = {\n        scrollOffset: -100,\n        scrollThrottle: 300\n      };\n\n      // Priviledged properties\n      this.scope = scope;\n      this.attrs = attrs;\n      this.element = $(element);\n      this.options = angular.extend({}, defaultOptions, this.scope.$eval(this.attrs.endlessScrollOptions));\n      this.docWindow = $($window);\n      this.window = this.options.window ? $(this.options.window) : this.docWindow;\n      this.dimension = { window: {}, parent: {}, items: [] };\n      this.status = {};\n      this.expression = parseNgRepeatExp(this.attrs.endlessScroll);\n\n      // Watch for events and scope changes\n      this._watch();\n    }\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#check\n     *\n     * @description\n     * Check to see if more items need to be fetched\n     * by checking if the user has scrolled to the bottom or top.\n     */\n    EndlessScroller.prototype.check = function () {\n      // Determine if scrolling up or down and if we reach the end of list or not\n      angular.extend(this.status, this._getScrollStatus());\n\n      // Determine window dimension\n      this.dimension.window = this._getDimension('window');\n\n      // Determine parent element dimension\n      this.dimension.parent = this._getDimension('parent');\n\n      // Clean up off-screen elements\n      this.clean();\n\n      // If scrolled to bottom, request more items\n      if (this.status.isEndReached && this.status.isScrollingDown && this.dimension.parent.bottom + this.options.scrollOffset <= this.dimension.window.bottom) {\n        this.next();\n      }\n\n      // If scrolled to top, request more items\n      if (this.status.isStartReached && this.status.isScrollingUp && this.dimension.parent.top - this.options.scrollOffset >= this.dimension.window.top) {\n        this.previous();\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#next\n     *\n     * @description\n     * Request the next page of items by notifying its parent controller.\n     */\n    EndlessScroller.prototype.next = function () {\n      if (!this.status.isPendingNext) {\n        this._setPending('next', true);\n\n        // Notify parent scope\n        this.scope.$emit('endlessScroll:next', this);\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#previous\n     *\n     * @description\n     * Request the previous page of items by notifying its parent controller.\n     */\n    EndlessScroller.prototype.previous = function () {\n      if (!this.status.isPendingPrevious) {\n        this._setPending('previous', true);\n\n        // Notify parent scope\n        this.scope.$emit('endlessScroll:previous', this);\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#update\n     * @param {Array} collection A list of items bound to the directive.\n     *\n     * @description\n     * Insert new items before or after a list of existing items and render them.\n     */\n    EndlessScroller.prototype.update = function (collection) {\n      var beforeItems, afterItems, firstCommonItemIndex, lastCommonItemIndex, oldCollection, i, len;\n\n      // KLUGE: collection == oldCollection before AngularJS 1.2.15\n      oldCollection = this.previousOriginalItems;\n\n      // Retain reference to original items\n      this.originalItems = collection;\n\n      // Get new items\n      if (angular.isArray(collection) && angular.isArray(oldCollection)) {\n        // Find first common item index\n        for (i = 0, len = collection.length; i < len; i++) {\n          if (collection[i] === oldCollection[0] && collection[i] !== undefined) {\n            firstCommonItemIndex = i;\n            break;\n          }\n        }\n\n        // Find last common item index\n        for (i = collection.length - 1; i >= 0; i--) {\n          if (collection[i] === oldCollection[oldCollection.length - 1] && collection[i] !== undefined) {\n            lastCommonItemIndex = i;\n            break;\n          }\n        }\n\n        if (firstCommonItemIndex) {\n          beforeItems = collection.slice(0, firstCommonItemIndex);\n        }\n\n        if (lastCommonItemIndex) {\n          afterItems = collection.slice(lastCommonItemIndex + 1);\n        }\n      }\n\n      // Add to items\n      if (!angular.isArray(this.items) || this.items.length === 0) {\n        if (angular.isArray(collection)) {\n          this.items = collection.slice();\n        }\n      } else {\n        if (beforeItems) {\n          this.items.unshift.apply(this.items, beforeItems);\n        }\n\n        if (afterItems) {\n          this.items.push.apply(this.items, afterItems);\n        }\n      }\n\n      // Previous collection\n      if (angular.isArray(collection)) {\n        this.previousOriginalItems = collection.slice();\n      }\n\n      // Flag status\n      $timeout(angular.bind(this, function () {\n        this._setPending('next', false);\n        this._setPending('previous', false);\n\n        // Perform check\n        if (angular.isArray(collection) && angular.isArray(oldCollection)) {\n          this.check();\n        }\n      }));\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#clean\n     *\n     * @description\n     * Remove items which are not visible in the viewport from DOM\n     * and re-insert them when they become visible again.\n     */\n    EndlessScroller.prototype.clean = function () {\n      var firstVisibleItemIndex,\n          lastVisibleItemIndex,\n          defaultPlaceholderAttrs,\n          placeholderHeight,\n          itemTagName,\n          newItems,\n          children,\n          parent = this._getParent();\n\n      // Set default placeholder attrs\n      defaultPlaceholderAttrs = {\n        visibility: 'hidden',\n        padding: 0,\n        border: 0\n      };\n\n      // Determine dimension of each repeated element\n      this.dimension.items = this._getDimension('items');\n\n      if (this.dimension.items && this.originalItems && this.dimension.items.length === this.originalItems.length) {\n        // Determine tag name\n        children = this._getChildren();\n        itemTagName = children.get(0) && children.prop('tagName').toLowerCase();\n\n        // Determine first and last visible item\n        angular.forEach(this.dimension.items, function (dimension, itemIndex) {\n          var isVisible = dimension.bottom >= this.dimension.window.top - this.dimension.window.height && dimension.top <= this.dimension.window.bottom + this.dimension.window.height;\n\n          // Set reference to item index\n          if (isVisible) {\n            if (firstVisibleItemIndex === undefined) {\n              firstVisibleItemIndex = itemIndex;\n            }\n\n            lastVisibleItemIndex = itemIndex;\n          }\n        }, this);\n\n        // Create placeholder\n        if (!this.placeholder && itemTagName) {\n          this.placeholder = $('<' + itemTagName + '>');\n\n          // Insert placeholder before all items\n          this.placeholder.css(defaultPlaceholderAttrs).prependTo(parent);\n        }\n\n        // Calculate total space occupied by items before the first visible item\n        if (this.placeholder) {\n          if (angular.isDefined(firstVisibleItemIndex)) {\n            placeholderHeight = this.dimension.items[firstVisibleItemIndex].top - this.dimension.parent.top;\n          } else {\n            placeholderHeight = 0;\n          }\n\n          this.placeholder.height(placeholderHeight);\n        }\n\n        // Add to items\n        if (angular.isDefined(firstVisibleItemIndex) && angular.isDefined(lastVisibleItemIndex) && angular.isArray(this.items) && angular.isArray(this.originalItems)) {\n          newItems = this.originalItems.slice(firstVisibleItemIndex, lastVisibleItemIndex + 1);\n          this.items.splice.apply(this.items, [0, this.items.length].concat(newItems));\n        }\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_watch\n     * @protected\n     *\n     * @description\n     * Watch for changes to scope properties and events fired by the scope and DOM\n     */\n    EndlessScroller.prototype._watch = function () {\n      var collectionExp = this.expression.collection;\n\n      if (collectionExp) {\n        // Watch for data changes\n        this.scope.$watchCollection(collectionExp, angular.bind(this, (function () {\n          function watchCollection() {\n            this.update.apply(this, arguments);\n          }\n\n          return watchCollection;\n        })()));\n\n        // Watch for onScroll event\n        this.window.on('scroll', this._boundOnScroll = angular.bind(this, this._onScroll));\n\n        // Watch for $destroy event\n        this.scope.$on('$destroy', angular.bind(this, this._unwatch));\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_unwatch\n     * @protected\n     *\n     * @description\n     * Watch for changes to scope properties and events fired by the scope and DOM\n     */\n    EndlessScroller.prototype._unwatch = function () {\n      if (this._boundOnScroll) {\n        this.window.off('scroll', this._boundOnScroll);\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_setPending\n     * @protected\n     * @param {string} type\n     * @param {boolean} [bool=true]\n     *\n     * @description\n     * Set a flag to indicate if the directive is pending for more items.\n     */\n    EndlessScroller.prototype._setPending = function (type, bool) {\n      var attr = 'isPending' + type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n\n      this.status[attr] = angular.isUndefined(bool) ? true : !!bool;\n      this.timeouts = this.timeouts || {};\n\n      if (this.status[attr]) {\n        if (this.timeouts[attr]) {\n          $timeout.cancel(this.timeouts[attr]);\n          delete this.timeouts[attr];\n        }\n\n        // Automatically set the wait status to false after a time period\n        this.timeouts[attr] = $timeout(angular.bind(this, function () {\n          this.status[attr] = false;\n        }), 5000);\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_onScroll\n     * @protected\n     *\n     * @description\n     * An event handler for scrolling.\n     */\n    EndlessScroller.prototype._onScroll = function () {\n      this.scope.$apply(angular.bind(this, function () {\n        // Define a throttled check method, if it's not already defined\n        if (!this._throttledCheck) {\n          this._throttledCheck = throttle(angular.bind(this, this.check), this.options.scrollThrottle);\n        }\n\n        // Check if there's a need to fetch more data\n        this._throttledCheck();\n      }));\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_getParent\n     * @protected\n     * @returns {Object} The parent element of the directive element.\n     *\n     * @description\n     * Find the parent element of the directive and return it.\n     */\n    EndlessScroller.prototype._getParent = function () {\n      if (!this._parent || !this._parent.get(0)) {\n        this._parent = this.element.parent();\n      }\n\n      return this._parent;\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_getOffsetTop\n     * @protected\n     * @returns {Number} The offset top of an element relative to the document\n     *\n     * @description\n     * Get the offset top of an element\n     */\n    EndlessScroller.prototype._getOffsetTop = function (element) {\n      var offset = element.offset();\n\n      if (this.window.get(0) === $window) {\n        return offset.top;\n      } else {\n        return offset.top + this.window.scrollTop() - this.docWindow.scrollTop();\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_getDimension\n     * @protected\n     * @param {string} type\n     */\n    EndlessScroller.prototype._getDimension = function (type) {\n      var height,\n          top,\n          bottom,\n          parent = this._getParent();\n\n      switch (type) {\n        case 'window':\n          height = this.window.outerHeight();\n          top = this.window.scrollTop();\n          bottom = top + height;\n\n          return {\n            height: height,\n            top: top,\n            bottom: bottom\n          };\n\n        case 'parent':\n          height = parent.outerHeight();\n          top = parent.get(0) && this._getOffsetTop(parent);\n          bottom = top + height;\n\n          return {\n            height: height,\n            top: top,\n            bottom: bottom\n          };\n\n        case 'items':\n          var itemIndex,\n              items = this.dimension.items.slice();\n\n          this._getChildren().each(angular.bind(this, function (i, child) {\n            child = $(child);\n            height = child.outerHeight();\n            top = child.get(0) && this._getOffsetTop(child);\n            bottom = top + height;\n            itemIndex = $.inArray(child.scope()[this.expression.item], this.originalItems);\n\n            // Set reference to the dimension of each visible element\n            if (itemIndex > -1) {\n              items[itemIndex] = {\n                height: height,\n                top: top,\n                bottom: bottom\n              };\n            }\n          }));\n\n          return items;\n      }\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_getScrollStatus\n     * @protected\n     * @returns {Object} An object containing information about the scroll status of the directive element.\n     */\n    EndlessScroller.prototype._getScrollStatus = function () {\n      var windowTop = this.window.scrollTop(),\n          status = {};\n\n      if (this.dimension.window.top > 0) {\n        status.isScrollingUp = windowTop - this.dimension.window.top < 0;\n        status.isScrollingDown = windowTop - this.dimension.window.top > 0;\n      } else {\n        status.isScrollingUp = false;\n        status.isScrollingDown = true;\n      }\n\n      if (angular.isArray(this.items) && angular.isArray(this.originalItems)) {\n        status.isEndReached = this.items[this.items.length - 1] === this.originalItems[this.originalItems.length - 1];\n        status.isStartReached = this.items[0] === this.originalItems[0];\n      } else {\n        status.isEndReached = true;\n        status.isStartReached = false;\n      }\n\n      return status;\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScroller#_getChildren\n     * @protected\n     * @returns The child elements of the directive element. It is the list of items which are currently rendered in DOM.\n     */\n    EndlessScroller.prototype._getChildren = function () {\n      var selector = '[ng-repeat]';\n\n      return this._getParent().children(selector);\n    };\n\n    /**\n     * @constructor dc.endlessScroll.EndlessScrollerTemplate\n     * @param {Object} element The directive element.\n     * @param {Object} attrs The directive attributes.\n     *\n     * @description\n     * The template of endlessScroll directive.\n     */\n    function EndlessScrollerTemplate(element, attrs) {\n      this.html = this._create(element, attrs);\n    }\n\n    /**\n     * @function dc.endlessScroll.EndlessScrollerTemplate#toString\n     * @returns {String} The template element as HTML string\n     */\n    EndlessScrollerTemplate.prototype.toString = function () {\n      return this.html;\n    };\n\n    /**\n     * @function dc.endlessScroll.EndlessScrollerTemplate#_create\n     * @param element {Object}\n     * @param attrs {Object}\n     * @returns {String} The template element as HTML string\n     *\n     * @description\n     * Create a template element for the directive.\n     */\n    EndlessScrollerTemplate.prototype._create = function (element, attrs) {\n      var elementAttrs = Array.prototype.slice.call(element.prop('attributes'), 0),\n          parsedExp = parseNgRepeatExp(attrs.endlessScroll),\n          ngRepeatExp = parsedExp.item + ' in _endlessScroll.items' + (parsedExp.trackBy ? ' ' + parsedExp.trackBy : '');\n\n      // Remove all element attributes as 'replace' already copies over these attributes\n      angular.forEach(elementAttrs, function (attr) {\n        element.removeAttr(attr.name);\n      });\n\n      // Retain reference to the original repeat expression\n      element.attr('ng-repeat', ngRepeatExp);\n\n      return element.prop('outerHTML');\n    };\n\n    return {\n      restrict: 'A',\n      scope: true,\n      replace: true,\n\n      template: function (element, attrs) {\n        return new EndlessScrollerTemplate(element, attrs).toString();\n      },\n\n      controller: function ($scope, $element, $attrs) {\n        var endlessScroll = new EndlessScroller($scope, $element, $attrs);\n\n        $scope._endlessScroll = endlessScroll;\n\n        return endlessScroll;\n      }\n    };\n  });\n})();","ast":null,"map":{"version":3,"sources":["/client/angular/js/angular-endless-scroll.js"],"names":[],"mappings":";;;;;;AAMA,CAAC,YAAW;AACV,cAAY,CAAC;;;;;;;;;;;;AAYb,SAAO,CAAC,MAAM,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAAC;CACxC,CAAA,EAAG,CAAC;;AAEL,CAAC,YAAW;AACV,cAAY,CAAC;;AAEb,SAAO,CAAC,MAAM,CAAC,kBAAkB,CAAC;;;;;;;;GAQ/B,SAAS,CAAC,eAAe,EAAE,UAAS,OAAO,EAAE,QAAQ,EAAE;AACtD,QAAI,gBAAgB,GAAG,8DAA8D,CAAC;;;;;;;;;;;;AAYtF,aAAS,QAAQ,CAAC,EAAE,EAAE,KAAK,EAAE;AAC3B,UAAI,OAAO;UACP,QAAQ,GAAG,CAAC,CAAC;;AAEjB,aAAO,YAAW;AAChB,YAAI,OAAO,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE;YAC9B,SAAS,GAAG,KAAK,IAAI,OAAO,GAAG,QAAQ,CAAA,AAAC;YACxC,IAAI,GAAG,SAAS,CAAC;;AAErB,YAAI,SAAS,IAAI,CAAC,EAAE;AAClB,cAAI,OAAO,EAAE;AACX,oBAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;WAC1B;;AAED,iBAAO,GAAG,SAAS,CAAC;AACpB,kBAAQ,GAAG,OAAO,CAAC;;AAEnB,YAAE,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACtB,MAAM,IAAI,CAAC,OAAO,EAAE;AACnB,iBAAO,GAAG,QAAQ,CAAC,YAAW;AAC5B,mBAAO,GAAG,SAAS,CAAC;AACpB,oBAAQ,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;;AAEhC,cAAE,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;WACtB,EAAE,SAAS,CAAC,CAAC;SACf;OACF,CAAC;KACH;;;;;;;;;;;;AAYD,aAAS,gBAAgB,CAAC,UAAU,EAAE;AACpC,UAAI,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;;AAEjD,aAAO;AACL,YAAI,EAAE,OAAO,CAAC,CAAC,CAAC;AAChB,kBAAU,EAAE,OAAO,CAAC,CAAC,CAAC;AACtB,eAAO,EAAE,OAAO,CAAC,CAAC,CAAC;OACpB,CAAC;KACH;;;;;;;;;;;;AAYD,aAAS,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE;AAC9C,UAAI,cAAc,GAAG;AACnB,oBAAY,EAAE,CAAC,GAAG;AAClB,sBAAc,EAAE,GAAG;OACpB,CAAC;;;AAGF,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,UAAI,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC;AAC1B,UAAI,CAAC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,EAAE,EAAE,cAAc,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC;AACrG,UAAI,CAAC,SAAS,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC;AAC5B,UAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;AAC5E,UAAI,CAAC,SAAS,GAAG,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;AACvD,UAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACjB,UAAI,CAAC,UAAU,GAAG,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;;;AAG7D,UAAI,CAAC,MAAM,EAAE,CAAC;KACf;;;;;;;;;AASD,mBAAe,CAAC,SAAS,CAAC,KAAK,GAAG,YAAW;;AAE3C,aAAO,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC;;;AAGrD,UAAI,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;;;AAGrD,UAAI,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;;;AAGrD,UAAI,CAAC,KAAK,EAAE,CAAC;;;AAGb,UAAI,IAAI,CAAC,MAAM,CAAC,YAAY,IAAI,IAAI,CAAC,MAAM,CAAC,eAAe,IACvD,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,EAAE;AAC5F,YAAI,CAAC,IAAI,EAAE,CAAC;OACb;;;AAGD,UAAI,IAAI,CAAC,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,MAAM,CAAC,aAAa,IACvD,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE;AACtF,YAAI,CAAC,QAAQ,EAAE,CAAC;OACjB;KACF,CAAC;;;;;;;;AAQF,mBAAe,CAAC,SAAS,CAAC,IAAI,GAAG,YAAW;AAC1C,UAAI,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE;AAC9B,YAAI,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;;;AAG/B,YAAI,CAAC,KAAK,CAAC,KAAK,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;OAC9C;KACF,CAAC;;;;;;;;AAQF,mBAAe,CAAC,SAAS,CAAC,QAAQ,GAAG,YAAW;AAC9C,UAAI,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE;AAClC,YAAI,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;;;AAGnC,YAAI,CAAC,KAAK,CAAC,KAAK,CAAC,wBAAwB,EAAE,IAAI,CAAC,CAAC;OAClD;KACF,CAAC;;;;;;;;;AASF,mBAAe,CAAC,SAAS,CAAC,MAAM,GAAG,UAAS,UAAU,EAAE;AACtD,UAAI,WAAW,EACX,UAAU,EACV,oBAAoB,EACpB,mBAAmB,EACnB,aAAa,EACb,CAAC,EACD,GAAG,CAAC;;;AAGR,mBAAa,GAAG,IAAI,CAAC,qBAAqB,CAAC;;;AAG3C,UAAI,CAAC,aAAa,GAAG,UAAU,CAAC;;;AAGhC,UAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;;AAEjE,aAAK,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AACjD,cAAI,UAAU,CAAC,CAAC,CAAC,KAAK,aAAa,CAAC,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;AACrE,gCAAoB,GAAG,CAAC,CAAC;AACzB,kBAAM;WACP;SACF;;;AAGD,aAAK,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AAC3C,cAAI,UAAU,CAAC,CAAC,CAAC,KAAK,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;AAC5F,+BAAmB,GAAG,CAAC,CAAC;AACxB,kBAAM;WACP;SACF;;AAED,YAAI,oBAAoB,EAAE;AACxB,qBAAW,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,oBAAoB,CAAC,CAAC;SACzD;;AAED,YAAI,mBAAmB,EAAE;AACvB,oBAAU,GAAG,UAAU,CAAC,KAAK,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;SACxD;OACF;;;AAGD,UAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3D,YAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;AAC/B,cAAI,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC;SACjC;OACF,MAAM;AACL,YAAI,WAAW,EAAE;AACf,cAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;SACnD;;AAED,YAAI,UAAU,EAAE;AACd,cAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;SAC/C;OACF;;;AAGD,UAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;AAC/B,YAAI,CAAC,qBAAqB,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC;OACjD;;;AAGD,cAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,YAAW;AACrC,YAAI,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAChC,YAAI,CAAC,WAAW,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;;;AAGpC,YAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;AACjE,cAAI,CAAC,KAAK,EAAE,CAAC;SACd;OACF,CAAC,CAAC,CAAC;KACL,CAAC;;;;;;;;;AASF,mBAAe,CAAC,SAAS,CAAC,KAAK,GAAG,YAAW;AAC3C,UAAI,qBAAqB;UACrB,oBAAoB;UACpB,uBAAuB;UACvB,iBAAiB;UACjB,WAAW;UACX,QAAQ;UACR,QAAQ;UACR,MAAM,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;;;AAG/B,6BAAuB,GAAG;AACxB,kBAAU,EAAE,QAAQ;AACpB,eAAO,EAAE,CAAC;AACV,cAAM,EAAE,CAAC;OACV,CAAC;;;AAGF,UAAI,CAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;;AAEnD,UAAI,IAAI,CAAC,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC,aAAa,IAC1C,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE;;AAE7D,gBAAQ,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;AAC/B,mBAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,WAAW,EAAE,CAAC;;;AAGxE,eAAO,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,UAAS,SAAS,EAAE,SAAS,EAAE;AACnE,cAAI,SAAS,GAAG,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,IAC5E,SAAS,CAAC,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC;;;AAG7F,cAAI,SAAS,EAAE;AACb,gBAAI,qBAAqB,KAAK,SAAS,EAAE;AACvC,mCAAqB,GAAG,SAAS,CAAC;aACnC;;AAED,gCAAoB,GAAG,SAAS,CAAC;WAClC;SACF,EAAE,IAAI,CAAC,CAAC;;;AAGT,YAAI,CAAC,IAAI,CAAC,WAAW,IAAI,WAAW,EAAE;AACpC,cAAI,CAAC,WAAW,GAAG,CAAC,CAAC,GAAG,GAAG,WAAW,GAAG,GAAG,CAAC,CAAC;;;AAG9C,cAAI,CAAC,WAAW,CACb,GAAG,CAAC,uBAAuB,CAAC,CAC5B,SAAS,CAAC,MAAM,CAAC,CAAC;SACtB;;;AAGD,YAAI,IAAI,CAAC,WAAW,EAAE;AACpB,cAAI,OAAO,CAAC,SAAS,CAAC,qBAAqB,CAAC,EAAE;AAC5C,6BAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC;WACjG,MAAM;AACL,6BAAiB,GAAG,CAAC,CAAC;WACvB;;AAED,cAAI,CAAC,WAAW,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;SAC5C;;;AAGD,YAAI,OAAO,CAAC,SAAS,CAAC,qBAAqB,CAAC,IACxC,OAAO,CAAC,SAAS,CAAC,oBAAoB,CAAC,IACvC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAC3B,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;AACvC,kBAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,qBAAqB,EAAE,oBAAoB,GAAG,CAAC,CAAC,CAAC;AACrF,cAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC9E;OACF;KACF,CAAC;;;;;;;;;AASF,mBAAe,CAAC,SAAS,CAAC,MAAM,GAAG,YAAW;AAC5C,UAAI,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC;;AAE/C,UAAI,aAAa,EAAE;;AAEjB,YAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,aAAa,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI;AAAE,mBAAS,eAAe,GAAG;AACvF,gBAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;WACpC;;iBAFsE,eAAe;aAEpF,CAAC,CAAC;;;AAGJ,YAAI,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;;;AAGnF,YAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;OAC/D;KACF,CAAC;;;;;;;;;AASF,mBAAe,CAAC,SAAS,CAAC,QAAQ,GAAG,YAAW;AAC9C,UAAI,IAAI,CAAC,cAAc,EAAE;AACvB,YAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;OAChD;KACF,CAAC;;;;;;;;;;;AAWF,mBAAe,CAAC,SAAS,CAAC,WAAW,GAAG,UAAS,IAAI,EAAE,IAAI,EAAE;AAC3D,UAAI,IAAI,GAAG,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;;AAEpF,UAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC;AAC9D,UAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAC;;AAEpC,UAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;AACrB,YAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACvB,kBAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;AACrC,iBAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SAC5B;;;AAGD,YAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,YAAW;AAC3D,cAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;SAC3B,CAAC,EAAE,IAAI,CAAC,CAAC;OACX;KACF,CAAC;;;;;;;;;AASF,mBAAe,CAAC,SAAS,CAAC,SAAS,GAAG,YAAW;AAC/C,UAAI,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,YAAW;;AAE9C,YAAI,CAAC,IAAI,CAAC,eAAe,EAAE;AACzB,cAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;SAC9F;;;AAGD,YAAI,CAAC,eAAe,EAAE,CAAC;OACxB,CAAC,CAAC,CAAC;KACL,CAAC;;;;;;;;;;AAUF,mBAAe,CAAC,SAAS,CAAC,UAAU,GAAG,YAAW;AAChD,UAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;AACzC,YAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;OACtC;;AAED,aAAO,IAAI,CAAC,OAAO,CAAC;KACrB,CAAC;;;;;;;;;;AAUF,mBAAe,CAAC,SAAS,CAAC,aAAa,GAAG,UAAS,OAAO,EAAE;AAC1D,UAAI,MAAM,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;;AAE9B,UAAI,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;AAClC,eAAO,MAAM,CAAC,GAAG,CAAC;OACnB,MAAM;AACL,eAAO,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC;OAC1E;KACF,CAAC;;;;;;;AAOF,mBAAe,CAAC,SAAS,CAAC,aAAa,GAAG,UAAS,IAAI,EAAE;AACvD,UAAI,MAAM;UACN,GAAG;UACH,MAAM;UACN,MAAM,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;;AAE/B,cAAO,IAAI;AACT,aAAK,QAAQ;AACX,gBAAM,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;AACnC,aAAG,GAAM,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;AACjC,gBAAM,GAAG,GAAG,GAAG,MAAM,CAAC;;AAEtB,iBAAO;AACL,kBAAM,EAAE,MAAM;AACd,eAAG,EAAK,GAAG;AACX,kBAAM,EAAE,MAAM;WACf,CAAC;;AAAA,AAEJ,aAAK,QAAQ;AACX,gBAAM,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;AAC9B,aAAG,GAAM,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;AACrD,gBAAM,GAAG,GAAG,GAAG,MAAM,CAAC;;AAEtB,iBAAO;AACL,kBAAM,EAAE,MAAM;AACd,eAAG,EAAK,GAAG;AACX,kBAAM,EAAE,MAAM;WACf,CAAC;;AAAA,AAEJ,aAAK,OAAO;AACV,cAAI,SAAS;cACT,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;;AAEzC,cAAI,CAAC,YAAY,EAAE,CAChB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,UAAS,CAAC,EAAE,KAAK,EAAE;AAC1C,iBAAK,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;AACjB,kBAAM,GAAG,KAAK,CAAC,WAAW,EAAE,CAAC;AAC7B,eAAG,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AAChD,kBAAM,GAAG,GAAG,GAAG,MAAM,CAAC;AACtB,qBAAS,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;;;AAG/E,gBAAI,SAAS,GAAG,CAAC,CAAC,EAAE;AAClB,mBAAK,CAAC,SAAS,CAAC,GAAG;AACjB,sBAAM,EAAE,MAAM;AACd,mBAAG,EAAE,GAAG;AACR,sBAAM,EAAE,MAAM;eACf,CAAC;aACH;WACF,CAAC,CAAC,CAAC;;AAEN,iBAAO,KAAK,CAAC;AAAA,OAChB;KACF,CAAC;;;;;;;AAOF,mBAAe,CAAC,SAAS,CAAC,gBAAgB,GAAG,YAAW;AACtD,UAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;UACnC,MAAM,GAAG,EAAE,CAAC;;AAEhB,UAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,EAAE;AACjC,cAAM,CAAC,aAAa,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;AACjE,cAAM,CAAC,eAAe,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;OACpE,MAAM;AACL,cAAM,CAAC,aAAa,GAAG,KAAK,CAAC;AAC7B,cAAM,CAAC,eAAe,GAAG,IAAI,CAAC;OAC/B;;AAED,UAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;AACtE,cAAM,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9G,cAAM,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;OACjE,MAAM;AACL,cAAM,CAAC,YAAY,GAAG,IAAI,CAAC;AAC3B,cAAM,CAAC,cAAc,GAAG,KAAK,CAAC;OAC/B;;AAED,aAAO,MAAM,CAAC;KACf,CAAC;;;;;;;AAOF,mBAAe,CAAC,SAAS,CAAC,YAAY,GAAG,YAAW;AAClD,UAAI,QAAQ,GAAG,aAAa,CAAC;;AAE7B,aAAO,IAAI,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;KAC7C,CAAC;;;;;;;;;;AAUF,aAAS,uBAAuB,CAAC,OAAO,EAAE,KAAK,EAAE;AAC/C,UAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;KAC1C;;;;;;AAMD,2BAAuB,CAAC,SAAS,CAAC,QAAQ,GAAG,YAAW;AACtD,aAAO,IAAI,CAAC,IAAI,CAAC;KAClB,CAAC;;;;;;;;;;;AAWF,2BAAuB,CAAC,SAAS,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE,KAAK,EAAE;AACnE,UAAI,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;UACxE,SAAS,GAAG,gBAAgB,CAAC,KAAK,CAAC,aAAa,CAAC;UACjD,WAAW,GAAG,SAAS,CAAC,IAAI,GAAG,0BAA0B,IAAI,SAAS,CAAC,OAAO,GAAG,GAAG,GAAG,SAAS,CAAC,OAAO,GAAG,EAAE,CAAA,AAAC,CAAC;;;AAGnH,aAAO,CAAC,OAAO,CAAC,YAAY,EAAE,UAAS,IAAI,EAAE;AAC3C,eAAO,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;OAC/B,CAAC,CAAC;;;AAGH,aAAO,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;;AAEvC,aAAO,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;KAClC,CAAC;;AAEF,WAAO;AACL,cAAQ,EAAE,GAAG;AACb,WAAK,EAAE,IAAI;AACX,aAAO,EAAE,IAAI;;AAEb,cAAQ,EAAE,UAAS,OAAO,EAAE,KAAK,EAAE;AACjC,eAAO,AAAC,IAAI,uBAAuB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAE,QAAQ,EAAE,CAAC;OACjE;;AAED,gBAAU,EAAE,UAAS,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE;AAC7C,YAAI,aAAa,GAAG,IAAI,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;;AAElE,cAAM,CAAC,cAAc,GAAG,aAAa,CAAC;;AAEtC,eAAO,aAAa,CAAC;OACtB;KACF,CAAC;GACH,CAAC,CAAC;CACN,CAAA,EAAG,CAAC","file":"/client/angular/js/angular-endless-scroll.js.map","sourcesContent":["/*!\n * angular-endless-scroll.js v0.0.5\n * http://davidchin.me\n * Copyright 2014 David Chin\n * MIT License\n */\n(function() {\n  'use strict';\n\n  /**\n   * @namespace dc\n   */\n\n  /**\n   * @module dc.endlessScroll\n   *\n   * @description\n   * A module for implementing an endless/infinite scroll user interface.\n   */\n  angular.module('dc.endlessScroll', []);\n})();\n\n(function() {\n  'use strict';\n\n  angular.module('dc.endlessScroll')\n\n    /**\n     * @member dc.endlessScroll.endlessScroll\n     *\n     * @description\n     * A directive for implementing an endless scrolling list.\n     */\n    .directive('endlessScroll', function($window, $timeout) {\n      var NG_REPEAT_REGEXP = /^\\s*(.+)\\s+in\\s+([\\r\\n\\s\\S]*?)\\s*(\\s+track\\s+by\\s+(.+)\\s*)?$/;\n\n      /**\n       * @function throttle\n       * @private\n       * @param {Function} fn\n       * @param {number} delay\n       * @returns {Function}\n       *\n       * @description\n       * Return a function that only gets executed once within a given time period.\n       */\n      function throttle(fn, delay) {\n        var timeout,\n            previous = 0;\n\n        return function() {\n          var current = new Date().getTime(),\n              remaining = delay - (current - previous),\n              args = arguments;\n\n          if (remaining <= 0) {\n            if (timeout) {\n              $timeout.cancel(timeout);\n            }\n\n            timeout = undefined;\n            previous = current;\n\n            fn.apply(this, args);\n          } else if (!timeout) {\n            timeout = $timeout(function() {\n              timeout = undefined;\n              previous = new Date().getTime();\n\n              fn.apply(this, args);\n            }, remaining);\n          }\n        };\n      }\n\n      /**\n       * @function parseNgRepeatExp\n       * @private\n       * @param {string} expression\n       * @returns {Object}\n       *\n       * @description\n       * Parse ngRepeat expression and\n       * return the name of the loop variable, the collection and tracking expression\n       */\n      function parseNgRepeatExp(expression) {\n        var matches = expression.match(NG_REPEAT_REGEXP);\n\n        return {\n          item: matches[1],\n          collection: matches[2],\n          trackBy: matches[3]\n        };\n      }\n\n      /**\n       * @constructor dc.endlessScroll.EndlessScroller\n       * @param {Object} scope The scope of the directive.\n       * @param {Object} element The element of the directive.\n       * @param {Object} attrs The attributes of the directive.\n       *\n       * @description\n       * The controller of endlessScroll directive.\n       * Each directive creates an instance of EndlessScroller.\n       */\n      function EndlessScroller(scope, element, attrs) {\n        var defaultOptions = {\n          scrollOffset: -100,\n          scrollThrottle: 300\n        };\n\n        // Priviledged properties\n        this.scope = scope;\n        this.attrs = attrs;\n        this.element = $(element);\n        this.options = angular.extend({}, defaultOptions, this.scope.$eval(this.attrs.endlessScrollOptions));\n        this.docWindow = $($window);\n        this.window = this.options.window ? $(this.options.window) : this.docWindow;\n        this.dimension = { window: {}, parent: {}, items: [] };\n        this.status = {};\n        this.expression = parseNgRepeatExp(this.attrs.endlessScroll);\n\n        // Watch for events and scope changes\n        this._watch();\n      }\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#check\n       *\n       * @description\n       * Check to see if more items need to be fetched\n       * by checking if the user has scrolled to the bottom or top.\n       */\n      EndlessScroller.prototype.check = function() {\n        // Determine if scrolling up or down and if we reach the end of list or not\n        angular.extend(this.status, this._getScrollStatus());\n\n        // Determine window dimension\n        this.dimension.window = this._getDimension('window');\n\n        // Determine parent element dimension\n        this.dimension.parent = this._getDimension('parent');\n\n        // Clean up off-screen elements\n        this.clean();\n\n        // If scrolled to bottom, request more items\n        if (this.status.isEndReached && this.status.isScrollingDown &&\n            this.dimension.parent.bottom + this.options.scrollOffset <= this.dimension.window.bottom) {\n          this.next();\n        }\n\n        // If scrolled to top, request more items\n        if (this.status.isStartReached && this.status.isScrollingUp &&\n            this.dimension.parent.top - this.options.scrollOffset >= this.dimension.window.top) {\n          this.previous();\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#next\n       *\n       * @description\n       * Request the next page of items by notifying its parent controller.\n       */\n      EndlessScroller.prototype.next = function() {\n        if (!this.status.isPendingNext) {\n          this._setPending('next', true);\n\n          // Notify parent scope\n          this.scope.$emit('endlessScroll:next', this);\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#previous\n       *\n       * @description\n       * Request the previous page of items by notifying its parent controller.\n       */\n      EndlessScroller.prototype.previous = function() {\n        if (!this.status.isPendingPrevious) {\n          this._setPending('previous', true);\n\n          // Notify parent scope\n          this.scope.$emit('endlessScroll:previous', this);\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#update\n       * @param {Array} collection A list of items bound to the directive.\n       *\n       * @description\n       * Insert new items before or after a list of existing items and render them.\n       */\n      EndlessScroller.prototype.update = function(collection) {\n        var beforeItems,\n            afterItems,\n            firstCommonItemIndex,\n            lastCommonItemIndex,\n            oldCollection,\n            i,\n            len;\n\n        // KLUGE: collection == oldCollection before AngularJS 1.2.15\n        oldCollection = this.previousOriginalItems;\n\n        // Retain reference to original items\n        this.originalItems = collection;\n\n        // Get new items\n        if (angular.isArray(collection) && angular.isArray(oldCollection)) {\n          // Find first common item index\n          for (i = 0, len = collection.length; i < len; i++) {\n            if (collection[i] === oldCollection[0] && collection[i] !== undefined) {\n              firstCommonItemIndex = i;\n              break;\n            }\n          }\n\n          // Find last common item index\n          for (i = collection.length - 1; i >= 0; i--) {\n            if (collection[i] === oldCollection[oldCollection.length - 1] && collection[i] !== undefined) {\n              lastCommonItemIndex = i;\n              break;\n            }\n          }\n\n          if (firstCommonItemIndex) {\n            beforeItems = collection.slice(0, firstCommonItemIndex);\n          }\n\n          if (lastCommonItemIndex) {\n            afterItems = collection.slice(lastCommonItemIndex + 1);\n          }\n        }\n\n        // Add to items\n        if (!angular.isArray(this.items) || this.items.length === 0) {\n          if (angular.isArray(collection)) {\n            this.items = collection.slice();\n          }\n        } else {\n          if (beforeItems) {\n            this.items.unshift.apply(this.items, beforeItems);\n          }\n\n          if (afterItems) {\n            this.items.push.apply(this.items, afterItems);\n          }\n        }\n\n        // Previous collection\n        if (angular.isArray(collection)) {\n          this.previousOriginalItems = collection.slice();\n        }\n\n        // Flag status\n        $timeout(angular.bind(this, function() {\n          this._setPending('next', false);\n          this._setPending('previous', false);\n\n          // Perform check\n          if (angular.isArray(collection) && angular.isArray(oldCollection)) {\n            this.check();\n          }\n        }));\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#clean\n       *\n       * @description\n       * Remove items which are not visible in the viewport from DOM\n       * and re-insert them when they become visible again.\n       */\n      EndlessScroller.prototype.clean = function() {\n        var firstVisibleItemIndex,\n            lastVisibleItemIndex,\n            defaultPlaceholderAttrs,\n            placeholderHeight,\n            itemTagName,\n            newItems,\n            children,\n            parent = this._getParent();\n\n        // Set default placeholder attrs\n        defaultPlaceholderAttrs = {\n          visibility: 'hidden',\n          padding: 0,\n          border: 0\n        };\n\n        // Determine dimension of each repeated element\n        this.dimension.items = this._getDimension('items');\n\n        if (this.dimension.items && this.originalItems &&\n            this.dimension.items.length === this.originalItems.length) {\n          // Determine tag name\n          children = this._getChildren();\n          itemTagName = children.get(0) && children.prop('tagName').toLowerCase();\n\n          // Determine first and last visible item\n          angular.forEach(this.dimension.items, function(dimension, itemIndex) {\n            var isVisible = dimension.bottom >= this.dimension.window.top - this.dimension.window.height &&\n                            dimension.top <= this.dimension.window.bottom + this.dimension.window.height;\n\n            // Set reference to item index\n            if (isVisible) {\n              if (firstVisibleItemIndex === undefined) {\n                firstVisibleItemIndex = itemIndex;\n              }\n\n              lastVisibleItemIndex = itemIndex;\n            }\n          }, this);\n\n          // Create placeholder\n          if (!this.placeholder && itemTagName) {\n            this.placeholder = $('<' + itemTagName + '>');\n\n            // Insert placeholder before all items\n            this.placeholder\n              .css(defaultPlaceholderAttrs)\n              .prependTo(parent);\n          }\n\n          // Calculate total space occupied by items before the first visible item\n          if (this.placeholder) {\n            if (angular.isDefined(firstVisibleItemIndex)) {\n              placeholderHeight = this.dimension.items[firstVisibleItemIndex].top - this.dimension.parent.top;\n            } else {\n              placeholderHeight = 0;\n            }\n\n            this.placeholder.height(placeholderHeight);\n          }\n\n          // Add to items\n          if (angular.isDefined(firstVisibleItemIndex) &&\n              angular.isDefined(lastVisibleItemIndex) &&\n              angular.isArray(this.items) &&\n              angular.isArray(this.originalItems)) {\n            newItems = this.originalItems.slice(firstVisibleItemIndex, lastVisibleItemIndex + 1);\n            this.items.splice.apply(this.items, [0, this.items.length].concat(newItems));\n          }\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_watch\n       * @protected\n       *\n       * @description\n       * Watch for changes to scope properties and events fired by the scope and DOM\n       */\n      EndlessScroller.prototype._watch = function() {\n        var collectionExp = this.expression.collection;\n\n        if (collectionExp) {\n          // Watch for data changes\n          this.scope.$watchCollection(collectionExp, angular.bind(this, function watchCollection() {\n            this.update.apply(this, arguments);\n          }));\n\n          // Watch for onScroll event\n          this.window.on('scroll', this._boundOnScroll = angular.bind(this, this._onScroll));\n\n          // Watch for $destroy event\n          this.scope.$on('$destroy', angular.bind(this, this._unwatch));\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_unwatch\n       * @protected\n       *\n       * @description\n       * Watch for changes to scope properties and events fired by the scope and DOM\n       */\n      EndlessScroller.prototype._unwatch = function() {\n        if (this._boundOnScroll) {\n          this.window.off('scroll', this._boundOnScroll);\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_setPending\n       * @protected\n       * @param {string} type\n       * @param {boolean} [bool=true]\n       *\n       * @description\n       * Set a flag to indicate if the directive is pending for more items.\n       */\n      EndlessScroller.prototype._setPending = function(type, bool) {\n        var attr = 'isPending' + type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n\n        this.status[attr] = angular.isUndefined(bool) ? true : !!bool;\n        this.timeouts = this.timeouts || {};\n\n        if (this.status[attr]) {\n          if (this.timeouts[attr]) {\n            $timeout.cancel(this.timeouts[attr]);\n            delete this.timeouts[attr];\n          }\n\n          // Automatically set the wait status to false after a time period\n          this.timeouts[attr] = $timeout(angular.bind(this, function() {\n            this.status[attr] = false;\n          }), 5000);\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_onScroll\n       * @protected\n       *\n       * @description\n       * An event handler for scrolling.\n       */\n      EndlessScroller.prototype._onScroll = function() {\n        this.scope.$apply(angular.bind(this, function() {\n          // Define a throttled check method, if it's not already defined\n          if (!this._throttledCheck) {\n            this._throttledCheck = throttle(angular.bind(this, this.check), this.options.scrollThrottle);\n          }\n\n          // Check if there's a need to fetch more data\n          this._throttledCheck();\n        }));\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_getParent\n       * @protected\n       * @returns {Object} The parent element of the directive element.\n       *\n       * @description\n       * Find the parent element of the directive and return it.\n       */\n      EndlessScroller.prototype._getParent = function() {\n        if (!this._parent || !this._parent.get(0)) {\n          this._parent = this.element.parent();\n        }\n\n        return this._parent;\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_getOffsetTop\n       * @protected\n       * @returns {Number} The offset top of an element relative to the document\n       *\n       * @description\n       * Get the offset top of an element\n       */\n      EndlessScroller.prototype._getOffsetTop = function(element) {\n        var offset = element.offset();\n\n        if (this.window.get(0) === $window) {\n          return offset.top;\n        } else {\n          return offset.top + this.window.scrollTop() - this.docWindow.scrollTop();\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_getDimension\n       * @protected\n       * @param {string} type\n       */\n      EndlessScroller.prototype._getDimension = function(type) {\n        var height,\n            top,\n            bottom,\n            parent = this._getParent();\n\n        switch(type) {\n          case 'window':\n            height = this.window.outerHeight();\n            top    = this.window.scrollTop();\n            bottom = top + height;\n\n            return {\n              height: height,\n              top:    top,\n              bottom: bottom\n            };\n\n          case 'parent':\n            height = parent.outerHeight();\n            top    = parent.get(0) && this._getOffsetTop(parent);\n            bottom = top + height;\n\n            return {\n              height: height,\n              top:    top,\n              bottom: bottom\n            };\n\n          case 'items':\n            var itemIndex,\n                items = this.dimension.items.slice();\n\n            this._getChildren()\n              .each(angular.bind(this, function(i, child) {\n                child = $(child);\n                height = child.outerHeight();\n                top = child.get(0) && this._getOffsetTop(child);\n                bottom = top + height;\n                itemIndex = $.inArray(child.scope()[this.expression.item], this.originalItems);\n\n                // Set reference to the dimension of each visible element\n                if (itemIndex > -1) {\n                  items[itemIndex] = {\n                    height: height,\n                    top: top,\n                    bottom: bottom\n                  };\n                }\n              }));\n\n            return items;\n        }\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_getScrollStatus\n       * @protected\n       * @returns {Object} An object containing information about the scroll status of the directive element.\n       */\n      EndlessScroller.prototype._getScrollStatus = function() {\n        var windowTop = this.window.scrollTop(),\n            status = {};\n\n        if (this.dimension.window.top > 0) {\n          status.isScrollingUp = windowTop - this.dimension.window.top < 0;\n          status.isScrollingDown = windowTop - this.dimension.window.top > 0;\n        } else {\n          status.isScrollingUp = false;\n          status.isScrollingDown = true;\n        }\n\n        if (angular.isArray(this.items) && angular.isArray(this.originalItems)) {\n          status.isEndReached = this.items[this.items.length - 1] === this.originalItems[this.originalItems.length - 1];\n          status.isStartReached = this.items[0] === this.originalItems[0];\n        } else {\n          status.isEndReached = true;\n          status.isStartReached = false;\n        }\n\n        return status;\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScroller#_getChildren\n       * @protected\n       * @returns The child elements of the directive element. It is the list of items which are currently rendered in DOM.\n       */\n      EndlessScroller.prototype._getChildren = function() {\n        var selector = '[ng-repeat]';\n\n        return this._getParent().children(selector);\n      };\n\n      /**\n       * @constructor dc.endlessScroll.EndlessScrollerTemplate\n       * @param {Object} element The directive element.\n       * @param {Object} attrs The directive attributes.\n       *\n       * @description\n       * The template of endlessScroll directive.\n       */\n      function EndlessScrollerTemplate(element, attrs) {\n        this.html = this._create(element, attrs);\n      }\n\n      /**\n       * @function dc.endlessScroll.EndlessScrollerTemplate#toString\n       * @returns {String} The template element as HTML string\n       */\n      EndlessScrollerTemplate.prototype.toString = function() {\n        return this.html;\n      };\n\n      /**\n       * @function dc.endlessScroll.EndlessScrollerTemplate#_create\n       * @param element {Object}\n       * @param attrs {Object}\n       * @returns {String} The template element as HTML string\n       *\n       * @description\n       * Create a template element for the directive.\n       */\n      EndlessScrollerTemplate.prototype._create = function(element, attrs) {\n        var elementAttrs = Array.prototype.slice.call(element.prop('attributes'), 0),\n            parsedExp = parseNgRepeatExp(attrs.endlessScroll),\n            ngRepeatExp = parsedExp.item + ' in _endlessScroll.items' + (parsedExp.trackBy ? ' ' + parsedExp.trackBy : '');\n\n        // Remove all element attributes as 'replace' already copies over these attributes\n        angular.forEach(elementAttrs, function(attr) {\n          element.removeAttr(attr.name);\n        });\n\n        // Retain reference to the original repeat expression\n        element.attr('ng-repeat', ngRepeatExp);\n\n        return element.prop('outerHTML');\n      };\n\n      return {\n        restrict: 'A',\n        scope: true,\n        replace: true,\n\n        template: function(element, attrs) {\n          return (new EndlessScrollerTemplate(element, attrs)).toString();\n        },\n\n        controller: function($scope, $element, $attrs) {\n          var endlessScroll = new EndlessScroller($scope, $element, $attrs);\n\n          $scope._endlessScroll = endlessScroll;\n\n          return endlessScroll;\n        }\n      };\n    });\n})();\n"]},"hash":"5d40b8aaf0160e0d608ab675965a3e2f1b04661c"}
